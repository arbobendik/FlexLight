var Vector=class extends Float32Array{get x(){if(0<this.length)return this[0];throw new Error("Vector has no x component")}get y(){if(1<this.length)return this[1];throw new Error("Vector has no y component")}get z(){if(2<this.length)return this[2];throw new Error("Vector has no z component")}get w(){if(3<this.length)return this[3];throw new Error("Vector has no w component")}set x(e){this[0]=e}set y(e){this[1]=e}set z(e){this[2]=e}set w(e){this[3]=e}constructor(...e){let t=!0;for(var i of e)"number"!=typeof i&&(t=!1);if(1!==e.length||t){if(!t)throw new Error("Invalid arguments for Vector constructor.");super(e)}else"vector_length"in e[0]?super(e[0].vector_length):super(e[0])}*[Symbol.iterator](){for(let e=0;e<this.length;e++)yield this[e]}},ZeroVector=class extends Vector{constructor(t){super({vector_length:t});for(let e=0;e<t;e++)this[e]=0}},Matrix=class extends Array{get(e,t){return this[e][t]}set(e,t,i){this[e][t]=i}constructor(...e){Object.defineProperty(this,"height",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"width",{enumerable:!0,configurable:!0,writable:!0,value:void 0});let t=!0;for(var i of e)Array.isArray(i)||(t=!1);if(1===e.length&&"matrix_height"in e[0]&&"matrix_width"in e[0]){var n=e[0];super(n.matrix_height),this.height=n.matrix_height,this.width=n.matrix_width;for(let e=0;e<n.matrix_height;e++)this[e]=new Vector({vector_length:n.matrix_width})}else{if(t){if(!t)throw new Error("Invalid number of rows");super(...e.map(e=>new Vector(e)))}else super(...e);this.height=this.length,this.width=this[0].length}}*[Symbol.iterator](){for(let e=0;e<this.length;e++)yield this[e]}},IdentityMatrix=class extends Matrix{constructor(t){super({matrix_height:t,matrix_width:t});for(let e=0;e<t;e++)this[e][e]=1}},ZeroMatrix=class extends Matrix{constructor(t,i){super({matrix_height:t,matrix_width:i});for(let e=0;e<t;e++)this[e]=new ZeroVector(i)}},HouseholderMatrix=class extends IdentityMatrix{constructor(e){super(e.length);var i=outer(e,e),n=2/dot(e,e);for(let t=0;t<this.height;t++)for(let e=0;e<this.width;e++)this[t][e]-=n*i[t][e]}};function dot(t,i){let n=0;for(let e=0;e<t.length;e++)n+=t[e]*i[e];return n}function outer(i,n){var r=new Matrix({matrix_height:i.length,matrix_width:n.length});for(let t=0;t<r.height;t++)for(let e=0;e<r.width;e++)r[t][e]=i[t]*n[e];return r}var Camera=class{position=new ZeroVector(3);direction=new ZeroVector(2);fov=1/Math.PI},Config=class{antialiasing="fxaa";temporal=!0;hdr=!0;renderQuality=1;samplesPerRay=1;maxReflections=5;minImportancy=.3;temporalSamples=4},Math2=window.Math,BIAS=(Object.assign(Math2,{BIAS:2**-32,stabilize:e=>Math2.abs(e)%1<Math2.BIAS||Math2.abs(e)%1>1-Math2.BIAS?Math2.round(e):e,sum:function(){return Array.prototype.slice.call(arguments).reduce((e,t)=>e+t,0)},mul:(t,i)=>{var e=(n,e)=>{let r=Math2.transpose(e);return n.map(()=>new Array(e[0].length).fill(0)).map((e,i)=>e.map((e,t)=>Math2.dot(n[i],r[t])))};let n=e=>Array.isArray(e)?n(e[0])+1:0;var r=n(t),a=n(i);switch(r){case 0:switch(a){case 0:return t*i;case 1:return i.map(e=>Math2.stabilize(e*t));case 2:return i.map(e=>e.map(e=>e*t))}case 1:switch(a){case 0:return t.map(e=>Math2.stabilize(e*i));case 1:return t.map((e,t)=>Math2.stabilize(e*i[t]));case 2:return}case 2:switch(a){case 0:return t.map(e=>e.map(e=>e*i));case 1:return e(t,i.map(e=>[e])).flat();case 2:return e(t,i)}}},dot:(e,t)=>Math2.stabilize(Math2.mul(e,t).reduce((e,t)=>e+t,0)),cross:(e,t)=>[e[1]*t[2]-e[2]*t[1],e[2]*t[0]-e[0]*t[2],e[0]*t[1]-e[1]*t[0]],add:(e,i)=>e.map((e,t)=>e+i[t]),diff:(e,i)=>e.map((e,t)=>e-i[t]),length:e=>Math2.stabilize(Math2.sqrt(e.reduce((e,t)=>e+t**2,0))),normalize:e=>{let t=Math2.length(e);return e.map(e=>Math2.stabilize(t)<Math2.BIAS?0:Math2.stabilize(e/t))},identity:t=>{var i=new Array(t).fill(0).map(e=>new Array(t).fill(0));for(let e=0;e<t;e++)i[e][e]=1;return i},gramSchmidt:(e,n=Math2.dot)=>{let t=[];return e.forEach(i=>{t.push(Math2.add(i,Math2.mul(-1,t.reduce((e,t)=>Math2.add(e,Math2.mul(n(t,i)/n(t,t),t)),new Array(e[0].length).fill(0)))))}),t},transpose:n=>n[0].map(()=>new Array(n.length).fill(0)).map((e,i)=>e.map((e,t)=>n[t][i])),qr:e=>{var t=Math2.gramSchmidt(Math2.transpose(e)).map(e=>Math2.normalize(e));return{Q:Math2.transpose(t),R:Math2.mul(t,e)}},moorePenrose:e=>{var t=Math2.transpose(e),n=Math2.qr(Math2.mul(t,e)),r=new Array(n.R.length);for(let i=n.R.length-1;0<=i;i--){r[i]=n.R.map((e,t)=>i===t?1:0);for(let e=n.R.length-1;e>i;e--)r[i]=Math2.add(r[i],Math2.mul(r[e],-n.R[i][e]/n.R[e][e]))}for(let e=0;e<n.R.length;e++)r[e]=Math2.mul(r[e],1/n.R[e][e]);return Number.isNaN(r[0][0])?Math2.transpose(Math2.moorePenrose(t)):Math2.mul(Math2.mul(r,Math2.transpose(n.Q)),t)},regression:(i,n)=>{var r=i.map(()=>new Array(n+1));for(let t=0;t<i.length;t++)for(let e=0;e<=n;e++)r[t][e]=i[t][0]**e;var e=i.map(e=>e[1]);return Math2.mul(Math2.moorePenrose(r),e)},rayTriangle:(e,t,i,n,r,a)=>{var o,s=2**-12,a=Math2.dot(a,Math2.diff(i,e))/Math2.dot(a,Math2.normalize(t));return a<=s||(t=Math2.add(Math2.mul(a,Math2.normalize(t)),e),e=Math2.diff(n,i),n=Math2.diff(r,i),r=Math2.diff(t,i),t=Math2.dot(e,e),i=Math2.dot(e,n),o=Math2.dot(n,n),e=Math2.dot(r,e),r=Math2.dot(r,n),Math2.min(t=1-(o=(o*e-i*r)/(n=t*o-i*i))-(t*r-i*e)/n,o)<=s)||1-s<=t+o?1/0:a},sigmoid:e=>1/(1+Math2.E**-e),sigmoidPrime:e=>Math2.sigmoid(e)*(1-Math2.sigmoid(e)),mod:(e,t)=>e-t*Math2.floor(e/t)}),1e-10),Vector3=class extends Float32Array{get x(){if(0<this.length)return this[0];throw new Error("Vector has no x component")}get y(){if(1<this.length)return this[1];throw new Error("Vector has no y component")}get z(){if(2<this.length)return this[2];throw new Error("Vector has no z component")}get w(){if(3<this.length)return this[3];throw new Error("Vector has no w component")}set x(e){this[0]=e}set y(e){this[1]=e}set z(e){this[2]=e}set w(e){this[3]=e}constructor(...e){let t=!0;for(var i of e)"number"!=typeof i&&(t=!1);if(1!==e.length||t){if(!t)throw new Error("Invalid arguments for Vector constructor.");super(e)}else"vector_length"in e[0]?super(e[0].vector_length):super(e[0])}*[Symbol.iterator](){for(let e=0;e<this.length;e++)yield this[e]}},ZeroVector2=class extends Vector3{constructor(t){super({vector_length:t});for(let e=0;e<t;e++)this[e]=0}},Matrix2=class extends Array{height;width;get(e,t){return this[e][t]}set(e,t,i){this[e][t]=i}constructor(...e){let t=!0;for(var i of e)Array.isArray(i)||(t=!1);if(1===e.length&&"matrix_height"in e[0]&&"matrix_width"in e[0]){var n=e[0];super(n.matrix_height),this.height=n.matrix_height,this.width=n.matrix_width;for(let e=0;e<n.matrix_height;e++)this[e]=new Vector3({vector_length:n.matrix_width})}else{if(t){if(!t)throw new Error("Invalid number of rows");super(...e.map(e=>new Vector3(e)))}else super(...e);this.height=this.length,this.width=this[0].length}}*[Symbol.iterator](){for(let e=0;e<this.length;e++)yield this[e]}},IdentityMatrix2=class extends Matrix2{constructor(t){super({matrix_height:t,matrix_width:t});for(let e=0;e<t;e++)this[e][e]=1}},HouseholderMatrix2=class extends IdentityMatrix2{constructor(e){super(e.length);var i=outer2(e,e),n=2/dot2(e,e);for(let t=0;t<this.height;t++)for(let e=0;e<this.width;e++)this[t][e]-=n*i[t][e]}};function vector_add(t,i){var n=new Vector3({vector_length:t.length});for(let e=0;e<t.length;e++)n[e]=t[e]+i[e];return n}function vector_scale(t,i){var n=new Vector3({vector_length:t.length});for(let e=0;e<t.length;e++)n[e]=t[e]*i;return n}function dot2(t,i){let n=0;for(let e=0;e<t.length;e++)n+=t[e]*i[e];return n}function normalize(t){var i=new ZeroVector2(t.length),n=Math.sqrt(dot2(t,t));if(!(Math.abs(n)<BIAS))for(let e=0;e<t.length;e++)i[e]=t[e]/n;return i}function outer2(i,n){var r=new Matrix2({matrix_height:i.length,matrix_width:n.length});for(let t=0;t<r.height;t++)for(let e=0;e<r.width;e++)r[t][e]=i[t]*n[e];return r}function transpose(i){var n=new Matrix2({matrix_height:i.width,matrix_width:i.height});for(let t=0;t<n.height;t++)for(let e=0;e<n.width;e++)n[t][e]=i[e][t];return n}function matrix_scale(t,i){var n=new Matrix2({matrix_height:t.height,matrix_width:t.width});for(let e=0;e<n.height;e++)n[e]=vector_scale(t[e],i);return n}function matrix_mul(n,r){var a=new Matrix2({matrix_height:n.height,matrix_width:r.width});for(let i=0;i<a.height;i++)for(let t=0;t<a.width;t++)for(let e=0;e<n.width;e++)a[i][t]+=n[i][e]*r[e][t];return a}function qr(i){let e=new IdentityMatrix2(i.height),n=new Matrix2({matrix_height:i.height,matrix_width:i.width});for(let t=0;t<i.height;t++)for(let e=0;e<i.width;e++)n[t][e]=i[t][e];for(let t=0;t<Math.min(i.width,i.height-1);t++){var r=new ZeroVector2(i.height);for(let e=t;e<i.height;e++)r[e]=n[e][t];var a=Math.sqrt(dot2(r,r));if(!(Math.abs(a)<BIAS)){var o=-Math.sign(r[t]||1),s=new ZeroVector2(i.height),l=(s[t]=o*a,normalize(vector_add(r,s))),c=Math.sqrt(dot2(l,l));if(!(c<BIAS)){for(let e=t;e<i.height;e++)l[e]=l[e]/c;o=new HouseholderMatrix2(l);n=matrix_mul(o,n),e=matrix_mul(e,transpose(o))}}}return{Q:e,R:n}}function moore_penrose(e){var i=e.width,t=transpose(e),n=qr(matrix_mul(t,e)),r=new Matrix2({matrix_height:i,matrix_width:i});for(let t=i-1;0<=t;t--)for(let e=i-(r[t][t]=1);e>t;e--)r[t]=vector_add(r[t],vector_scale(r[e],-n.R[t][e]/n.R[e][e]));for(let e=0;e<i;e++)r[e]=vector_scale(r[e],1/n.R[e][e]);return matrix_mul(matrix_mul(r,transpose(n.Q)),t)}var Transform=class y1{referenceNumber=0;rotationMatrix;position;scaleFactor=1;transformedNodes=new Set;static NO_TRANSFORM;static used=[];static transformList=[];static buildWGL2Arrays=()=>{var t=y1.transformList.length,i=new Float32Array(24*t),n=new Float32Array(8*t);for(let e=0;e<t;e++){var r=y1.transformList[e]??y1.NO_TRANSFORM,a=r.matrix,o=moore_penrose(a),s=r.position,r=vector_scale(r.position,-1);i.set(a[0],24*e),i.set(a[1],24*e+4),i.set(a[2],24*e+8),i.set(o[0],24*e+12),i.set(o[1],24*e+16),i.set(o[2],24*e+20),n.set(s,8*e),n.set(r,8*e+4)}return{rotationBuffer:i,shiftBuffer:n}};static buildWGPUArray=()=>{var t=y1.transformList.length,i=new Float32Array(32*t);for(let e=0;e<t;e++){var n=y1.transformList[e]??y1.NO_TRANSFORM,r=n.matrix,a=moore_penrose(r),o=n.position,n=vector_scale(n.position,-1);i.set(r[0],32*e),i.set(r[1],32*e+4),i.set(r[2],32*e+8),i.set(o,32*e+12),i.set(a[0],32*e+16),i.set(a[1],32*e+20),i.set(a[2],32*e+24),i.set(n,32*e+28)}return i};get number(){return this.referenceNumber}get matrix(){return matrix_scale(this.rotationMatrix,this.scaleFactor)}move(e,t,i){this.position=new Vector3(e,t,i)}rotateAxis(e,t){var i=Math.sin(t),t=Math.cos(t);this.rotationMatrix=new Matrix2([e.x*e.x*(1-t)+t,e.x*e.y*(1-t)-e.z*i,e.x*e.z*(1-t)+e.y*i],[e.x*e.y*(1-t)+e.z*i,e.y*e.y*(1-t)+t,e.y*e.z*(1-t)-e.x*i],[e.x*e.z*(1-t)-e.y*i,e.y*e.z*(1-t)+e.x*i,e.z*e.z*(1-t)+t])}rotateSpherical(e,t){var i=Math.sin(e),e=Math.cos(e),n=Math.sin(t),t=Math.cos(t);this.rotationMatrix=new Matrix2([e,0,i],[-i*n,t,e*n],[-i*t,-n,e*t])}scale(e){this.scaleFactor=e}addNode(e){this.transformedNodes.add(e)}removeNode(e){this.transformedNodes.delete(e)}destroy(){y1.used[this.referenceNumber]=!1,y1.transformList[this.referenceNumber]=void 0}static classConstructor=void(y1.NO_TRANSFORM=new y1);constructor(){this.rotationMatrix=new IdentityMatrix2(3),this.position=new ZeroVector2(3);for(let e=0;e<1/0;e++)if(!y1.used[e]){y1.used[e]=!0,this.referenceNumber=e;break}y1.transformList[this.referenceNumber]=this}},BVH_MAX_LEAVES_PER_NODE=4,Scene=class gc{primaryLightSources=[[0,10,0]];defaultLightIntensity=200;defaultLightVariation=.4;ambientLight=[.025,.025,.025];textures=[];pbrTextures=[];translucencyTextures=[];standardTextureSizes=[1024,1024];queue=[];static async textureFromRGB(e,t,i){var n=document.createElement("canvas"),r=n.getContext("2d"),t=(n.width=t,n.height=i,r.imageSmoothingEnabled=!1,r.createImageData(t,i)),i=(t.data.set(new Uint8ClampedArray(e),0),r.putImageData(t,0,0),new Image);return i.src=n.toDataURL(),i}static async textureFromRME(t,e,i){var n=[];for(let e=0;e<t.length;e+=3)n.push(255*t[e],255*t[e+1],255*t[e+2],255);return this.textureFromRGB(n,e,i)}static fitsInBound(e,t){return e[0]<=t.bounding[0]&&e[2]<=t.bounding[2]&&e[4]<=t.bounding[4]&&e[1]>=t.bounding[1]&&e[3]>=t.bounding[3]&&e[5]>=t.bounding[5]}static generateBVH(e){let d=(n,r=0)=>{if(n.length<=BVH_MAX_LEAVES_PER_NODE||r>i)return t+=n.length,n;{var a=[(n.bounding[0]+n.bounding[1])/2,(n.bounding[2]+n.bounding[3])/2,(n.bounding[4]+n.bounding[5])/2];let t=0,i=1/0;var o=[];for(let e=0;e<3;e++){var s=n.bounding.concat(),l=n.bounding.concat(),c=(s[2*e]=a[e],l[2*e+1]=a[e],Math2.min(s[2*e+1]-a[e],a[e]-l[2*e])),s=((t,i,n)=>{let r=0;for(let e=0;e<t.length;e++)gc.fitsInBound(i,t[e])||gc.fitsInBound(n,t[e])||r++;return r})(n,s,l);o.push(s),i>=s&&1/256<c&&(t=e,i=s)}if(i===1/0)return console.error("OPTIMIZATION failed for subtree!",n.length),console.log(o),n;var u=[[],[],[]],h=[n.bounding,n.bounding.concat(),n.bounding.concat()];h[0][2*t]=a[t],h[1][2*t+1]=a[t];for(let e=0;e<n.length;e++)(gc.fitsInBound(h[0],n[e])?u[0]:gc.fitsInBound(h[1],n[e])?u[1]:u[2]).push(n[e]);var f,m=[];for(let e=0;e<3;e++)0!==u[e].length&&(f=new Bounding(u[e]),gc.updateBoundings(f),m.push(d(f,r+1)));var e=new Bounding(m);return e.bounding=n.bounding,e}};e=new Bounding(e);gc.updateBoundings(e);let t=0,i=Math2.log2(e.length)+8;return e=d(e),console.log("done building BVH-Tree"),console.log(i),e}static updateBoundings(t){let n=.00152587890625,r=new Array(6);if(Array.isArray(t)||t.indexable)if(0!==t.length||t.blockError){r=gc.updateBoundings(t[0]);for(let e=1;e<t.length;e++){let i=gc.updateBoundings(t[e]);r=r.map((e,t)=>t%2==0?Math2.min(e,i[t]-n):Math2.max(e,i[t]+n))}}else console.error("problematic object structure","isArray:",Array.isArray(t),"indexable:",t.indexable,"object:",t),t.blockError=!0;else{var i=t.vertices;r=[i[0],i[0],i[1],i[1],i[2],i[2]];for(let e=3;e<t.vertices.length;e++)r[e%3*2]=Math2.min(r[e%3*2],i[e]),r[e%3*2+1]=Math2.max(r[e%3*2+1],i[e])}return t.bounding=r}static generateArraysFromGraph(e){let i,n;let a,o,s,r=t=>{if(t.static)i+=t.textureLength,n+=t.bufferLength;else if(Array.isArray(t)||t.indexable){if(0!==t.length){i++;for(let e=0;e<t.length;e++)r(t[e])}}else i+=t.length,n+=t.length},l=t=>{if(t.static){a.set(t.geometryBuffer,12*c),o.set(t.sceneBuffer,28*c);for(let e=0;e<t.bufferLength;e++)s[u+e]=c+t.idBuffer[e];return c+=t.textureLength,u+=t.bufferLength,t.minMax}if(Array.isArray(t)||t.indexable){if(0===t.length)return[];var i=c,n=(c++,l(t[0]));for(let e=1;e<t.length;e++){var r=l(t[e]);n[0]=Math2.min(n[0],r[0]),n[1]=Math2.min(n[1],r[1]),n[2]=Math2.min(n[2],r[2]),n[3]=Math2.max(n[3],r[3]),n[4]=Math2.max(n[4],r[4]),n[5]=Math2.max(n[5],r[5])}for(let e=0;e<6;e++)a[12*i+e]=n[e];return a[12*i+6]=c-i-1,a[12*i+9]=t.transformNum??0,a[12*i+10]=1,n}a.set(t.geometryBuffer,12*c),o.set(t.sceneBuffer,28*c);for(let e=0;e<t.length;e++)s[u++]=c++;return t.aabb},c=(i=0,n=0,r(e),0),u=0;h=3072,console.log(Math2.ceil(12*i/h)*h),a=new Float32Array(Math2.ceil(12*i/h)*h),o=new Float32Array(7168*Math2.ceil(28*i/7168)),s=new Int32Array(n);var e=l(e),t=a.length/h,h=a.length/h;return{textureLength:i,bufferLength:n,idBuffer:s,minMax:e,geometryBufferHeight:t,geometryBuffer:a,sceneBufferHeight:h,sceneBuffer:o}}textureFromRGB=async(e,t,i)=>gc.textureFromRGB(e,t,i);textureFromRME=async(e,t,i)=>gc.textureFromRME(e,t,i);textureFromTPO=async(e,t,i)=>gc.textureFromRME(e,t,i);generateBVH(){return gc.generateBVH(this.queue)}updateBoundings(){return gc.updateBoundings(this.queue)}generateArraysFromGraph(){return gc.generateArraysFromGraph(this.queue)}Transform=e=>new Transform(e);Cuboid=(e,t,i,n,r,a)=>new Cuboid(e,t,i,n,r,a);Plane=(e,t,i,n)=>new Plane(e,t,i,n);Triangle=(e,t,i)=>new Triangle(e,t,i);Bounding=e=>new Bounding(e);importObj=async(e,a=[])=>{let o=[],s=[],l=[],c=[],u;e=await(await fetch(e)).text();return console.log("Parsing vertices ..."),e.split(/\r\n|\r|\n/).forEach(e=>(e=>{let t=[];switch(e.split(/[\t \s\s+]/g).forEach(e=>{e.length&&t.push(e)}),t[0]){case"v":s.push([Number(t[1]),Number(t[2]),Number(t[3])]);break;case"vt":l.push([Number(t[1]),Number(t[2])]);break;case"vn":c.push([Number(t[1]),Number(t[2]),Number(t[3])]);break;case"f":var r;let i=t.slice(1,t.length).join(" ").split(/[ ]/g).filter(e=>e.length).map(e=>e.split(/[/]/g).map(e=>{let t=Number(e);return t=t<0?s.length+t+1:t})),n;4===i.length?(n=new Plane(s[i[3][0]-1],s[i[2][0]-1],s[i[1][0]-1],s[i[0][0]-1]),[3,2,1,1,0,3].forEach((e,t)=>{void 0!==l[i[e][1]-1]&&n.uvs.set(l[i[e][1]-1],2*t),void 0!==c[i[e][2]-1]&&n.normals.set(c[i[e][2]-1],3*t)})):(n=new Triangle(s[i[2][0]-1],s[i[1][0]-1],s[i[0][0]-1]),[2,1,0].forEach((e,t)=>{void 0!==l[i[e][1]-1]&&n.uvs.set(l[i[e][1]-1],2*t),void 0!==c[i[e][2]-1]&&n.normals.set(c[i[e][2]-1],3*t)})),u&&(r=a[u],n.color=r.color??[255,255,255],n.emissiveness=r.emissiveness??0,n.metallicity=r.metallicity??0,n.roughness=r.roughness??1,n.translucency=r.translucency??0,n.ior=r.ior??1),o.push(n);break;case"usemtl":a[t[1]]?u=t[1]:console.warn("Couldn't resolve material",u)}})(e)),console.log("Generating BVH ..."),o=gc.generateBVH(o),gc.updateBoundings(o),o};importMtl=async e=>{let n=[],r;e=await(await fetch(e)).text();return console.log("Parsing materials ..."),e.split(/\r\n|\r|\n/).forEach(e=>(e=>{let t=[];switch(e.split(/[\t \s\s+]/g).forEach(e=>{e.length&&t.push(e)}),t[0]){case"newmtl":r=t[1],n[r]={};break;case"Ka":n[r].color=Math2.mul(255,[Number(t[1]),Number(t[2]),Number(t[3])]);break;case"Ke":var i=Math2.max(Number(t[1]),Number(t[2]),Number(t[3]));0<i&&(n[r].emissiveness=4*i,n[r].color=Math2.mul(255/i,[Number(t[1]),Number(t[2]),Number(t[3])]));break;case"Ns":n[r].metallicity=Number(t[1]/1e3);break;case"d":break;case"Ni":n[r].ior=Number(t[1])}})(e)),console.log(n),n}},Primitive=class{#vertices;#normal;#normals;#uvs;#transform;#textureNums=new Float32Array([-1,-1,-1]);#albedo=new Float32Array([1,1,1]);#rme=new Float32Array([1,0,0]);#tpo=new Float32Array([0,0,1]);geometryBuffer;sceneBuffer;#buildTextureArrays=()=>{for(let e=0;e<this.length;e++){var t=12*e,t=(this.geometryBuffer.set(this.#vertices.slice(9*e,9*e+9),t),this.geometryBuffer[9+t]=this.transformNum,this.geometryBuffer[10+t]=2,28*e);this.sceneBuffer.set(this.#normals.slice(9*e,9*e+9),t),this.sceneBuffer.set(this.#uvs.slice(6*e,6*e+6),9+t),this.sceneBuffer.set(this.#textureNums,15+t),this.sceneBuffer.set(this.#albedo,18+t),this.sceneBuffer.set(this.#rme,21+t),this.sceneBuffer.set(this.#tpo,24+t)}};get aabb(){var t=this.vertices,i=[t[0],t[1],t[2],t[0],t[1],t[2]];for(let e=3;e<t.length;e+=3)i[0]=Math2.min(i[0],t[e]),i[1]=Math2.min(i[1],t[e+1]),i[2]=Math2.min(i[2],t[e+2]),i[3]=Math2.max(i[3],t[e]),i[4]=Math2.max(i[4],t[e+1]),i[5]=Math2.max(i[5],t[e+2]);return i}get vertices(){return this.#vertices}get normals(){return this.#normals}get normal(){return this.#normal}get transformNum(){return this.#transform?this.#transform.number:0}get transform(){return this.#transform}get textureNums(){return this.#textureNums}get color(){return this.#albedo}get albedo(){return this.#albedo}get roughness(){return this.#rme[0]}get metallicity(){return this.#rme[1]}get emissiveness(){return this.#rme[2]}get translucency(){return this.#tpo[0]}get ior(){return this.#tpo[2]}get uvs(){return this.#uvs}set vertices(e){this.#vertices=new Float32Array(e),this.#buildTextureArrays()}set normals(e){this.#normals=new Float32Array(e),this.#normal=new Float32Array(e.slice(0,3)),this.#buildTextureArrays()}set normal(e){this.#normals=new Float32Array(new Array(3*this.length).fill(e).flat()),this.#normal=new Float32Array(e),this.#buildTextureArrays()}set transform(e){this.#transform&&this.#transform.deleteNode(this),e.addNode(this),this.setTransformRec(e)}setTransformRec=e=>{this.#transform=e,this.#buildTextureArrays()};set textureNums(e){this.#textureNums=e,this.#buildTextureArrays()}set color(e){e=e.map(e=>e/255);this.#albedo=new Float32Array(e),this.#buildTextureArrays()}set albedo(e){this.color=e}set roughness(e){this.#rme[0]=e,this.#buildTextureArrays()}set metallicity(e){this.#rme[1]=e,this.#buildTextureArrays()}set emissiveness(e){this.#rme[2]=e,this.#buildTextureArrays()}set translucency(e){this.#tpo[0]=e,this.#buildTextureArrays()}set ior(e){this.#tpo[2]=e,this.#buildTextureArrays()}set uvs(e){this.#uvs=new Float32Array(e),this.#buildTextureArrays()}constructor(e,t,i,n){this.indexable=!1,this.length=e,this.#vertices=new Float32Array(t),this.#normal=new Float32Array(i),this.#normals=new Float32Array(new Array(3*this.length).fill(i).flat()),this.#uvs=new Float32Array(n),this.geometryBuffer=new Float32Array(12*this.length),this.sceneBuffer=new Float32Array(28*this.length),this.#buildTextureArrays()}},Plane=class extends Primitive{constructor(e,t,i,n){super(2,[e,t,i,i,n,e].flat(),Math2.normalize(Math2.cross(Math2.diff(e,i),Math2.diff(e,t))),[0,0,0,1,1,1,1,1,1,0,0,0])}},Triangle=class extends Primitive{constructor(e,t,i){super(1,[e,t,i].flat(),Math2.normalize(Math2.cross(Math2.diff(e,i),Math2.diff(e,t))),[0,0,0,1,1,1])}},Object3D=class{#static=!1;#staticPermanent=!1;#transform;get transformNum(){return this.#transform?this.#transform.number:0}get transform(){return this.#transform}set transform(e){this.#transform&&this.#transform.deleteNode(this),e.addNode(this),this.setTransformRec(e)}setTransformRec=t=>{this.#transform=t;for(let e=0;e<this.length;e++)this[e].setTransformRec(t)};set textureNums(t){for(let e=0;e<this.length;e++)this[e].textureNums=t}set color(t){for(let e=0;e<this.length;e++)this[e].color=t}set albedo(t){for(let e=0;e<this.length;e++)this[e].albedo=t}set roughness(t){for(let e=0;e<this.length;e++)this[e].roughness=t}set metallicity(t){for(let e=0;e<this.length;e++)this[e].metallicity=t}set emissiveness(t){for(let e=0;e<this.length;e++)this[e].emissiveness=t}set translucency(t){for(let e=0;e<this.length;e++)this[e].translucency=t}set ior(t){for(let e=0;e<this.length;e++)this[e].ior=t}move(i,n,r){this.relativePosition=[i,n,r];for(let e=0;e<this.length;e++)this[e].indexable?this[e].move(i,n,r):this[e].vertices=this[e].vertices.map((e,t)=>{switch(t%3){case 0:return e+i;case 1:return e+n;case 2:return e+r}})}scale(i){for(let e=0;e<this.length;e++)this[e].indexable?this[e].scale(i):this[e].vertices=this[e].vertices.map((e,t)=>(e-this.relativePosition[t%3])*i+this.relativePosition[t%3])}set static(e){e?(e=Scene.generateArraysFromGraph(this),this.textureLength=e.textureLength,this.bufferLength=e.bufferLength,this.idBuffer=e.idBuffer,this.geometryBuffer=e.geometryBuffer,this.sceneBuffer=e.sceneBuffer,this.minMax=e.minMax,this.#static=!0):(this.#static=!1,this.textureLength=0,this.bufferLength=0,this.geometryBuffer=null,this.sceneBuffer=null,this.minMax=null)}get static(){return this.#static}set staticPermanent(e){if(this.#staticPermanent&&!e&&console.error("Can't unset static permanent, tree is permanently lost"),e){this.#staticPermanent=e,this.static=!0;for(let e=0;e<this.length;e++)this[e]=void 0}}get staticPermanent(){return this.#staticPermanent}constructor(e){this.relativePosition=[0,0,0],this.length=e,this.indexable=!0}},Bounding=class extends Object3D{constructor(e){super(e.length),e.forEach((e,t)=>this[t]=e)}},Cuboid=class extends Object3D{constructor(e,t,i,n,r,a){super(6);var o=.00152587890625;[e,i,r]=[e+o,i+o,r+o],[t,n,a]=[t-o,n-o,a-o],this.bounding=[e,t,i,n,r,a],this.top=new Plane([e,n,r],[t,n,r],[t,n,a],[e,n,a]),this.right=new Plane([t,n,r],[t,i,r],[t,i,a],[t,n,a]),this.front=new Plane([t,n,a],[t,i,a],[e,i,a],[e,n,a]),this.bottom=new Plane([e,i,a],[t,i,a],[t,i,r],[e,i,r]),this.left=new Plane([e,n,a],[e,i,a],[e,i,r],[e,n,r]),this.back=new Plane([e,n,r],[e,i,r],[t,i,r],[t,n,r]),[this.top,this.right,this.front,this.bottom,this.left,this.back].forEach((e,t)=>this[t]=e)}},GLLib=class ie{static postVertex=`#version 300 es
  in vec2 position2d;
  // Pass clip space position to fragment shader
  out vec2 clipSpace;
  void main() {
    vec2 pos = position2d * 2.0 - 1.0;
    // Set final clip space position
    gl_Position = vec4(pos, 0, 1);
    clipSpace = position2d;
  }
  `;static computeVertex=`#version 300 es
  in vec4 position;
  void main() {
    gl_Position = position;
  }`;static addCompileTimeConstant=(e,t,i)=>`#version 300 es
    #define `+t+" "+i+`
    `+e.slice(15);static compile=(n,e,t)=>{let i=[{source:e,type:n.VERTEX_SHADER},{source:t,type:n.FRAGMENT_SHADER}],r=n.createProgram();if(i.forEach(async(e,t)=>{var i=n.createShader(e.type);n.shaderSource(i,e.source),n.compileShader(i),n.getShaderParameter(i,n.COMPILE_STATUS)?n.attachShader(r,i):(console.warn(n.getShaderInfoLog(i)),console.log(e.source),n.deleteShader(i))}),n.linkProgram(r),n.getProgramParameter(r,n.LINK_STATUS))return r;console.warn(n.getProgramInfoLog(r)),n.deleteProgram(r)};static setTexParams=e=>{e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST)};static setByteTexture=(e,t,i,n)=>{var r=e.createTexture();return e.bindTexture(e.TEXTURE_2D,r),e.pixelStorei(e.UNPACK_ALIGNMENT,1),e.texImage2D(e.TEXTURE_2D,0,e.RGBA8,i,n,0,e.RGBA,e.UNSIGNED_BYTE,t),ie.setTexParams(e),r};static toFloat=e=>2*(e[0]+e[1]/255+e[2]/65025+e[3]/16581375)-255;static toBytes=e=>{e=(e+255)/2;let i=[e,255*e,65025*e,16581375*e];return i.map((e,t)=>i[t]=Math2.floor(Math2.mod(e,255)))}},fxaa_default="#version 300 es\n\n// Define FXAA constants\n#define FXAA_EDGE_THRESHOLD_MIN 1.0 / 32.0\n#define FXAA_EDGE_THRESHOLD 1.0 / 2.0\n#define FXAA_SUBPIX_TRIM 0.0\n#define FXAA_SUBPIX_TRIM_SCALE 1.0\n#define FXAA_SUBPIX_CAP 7.0 / 8.0\n#define FXAA_SEARCH_STEPS 6\nprecision highp float;\nin vec2 clipSpace;\nuniform sampler2D preRender;\nout vec4 out_color;\nvec2 texel;\n\nvec4 fetch(int x, int y) {\n    return texelFetch(preRender, ivec2(texel) + ivec2(x, y), 0);\n}\n\n// Color to luminance conversion from NVIDIA FXAA white paper\nfloat fxaa_luma(vec4 rgba) {\n    return (rgba.y * (0.587/0.299) + rgba.x) * rgba.w;\n}\n\nfloat tex_luma(int x, int y) {\n    // Devide length through square root of 3 to have a maximum length of 1\n    return fxaa_luma(fetch(x, y));\n}\n\n// Local contrast checker from NVIDIA FXAA white paper\nvec2 fxaa_contrast(int x, int y) {\n    return vec2(\n    min(tex_luma(x, y), min(min(tex_luma(x, y-1), tex_luma(x-1, y)), min(tex_luma(x, y+1), tex_luma(x+1, y)))),\n    max(tex_luma(x, y), max(max(tex_luma(x, y-1), tex_luma(x-1, y)), max(tex_luma(x, y+1), tex_luma(x+1, y))))\n    );\n}\n\n// Local low contrast checker from NVIDIA FXAA white paper\nbool fxaa_is_low_contrast(int x, int y) {\n    vec2 range_min_max = fxaa_contrast(x, y);\n    float range = range_min_max.y - range_min_max.x;\n    return (range < max(FXAA_EDGE_THRESHOLD_MIN, range_min_max.y * FXAA_EDGE_THRESHOLD));\n}\n\nvec4 blur_3x3(int x, int y) {\n    return 1.0 / 9.0 * (\n        fetch(x-1,y-1) + fetch(  x,y-1) + fetch(x+1,y-1)\n    + fetch(x-1,  y) + fetch(  x,  y) + fetch(x+1,  y)\n    + fetch(x-1,y+1) + fetch(  x,y+1) + fetch(x+1,y+1)\n    );\n}\n\nfloat fxaa_sub_pixel_aliasing(int x, int y) {\n    float luma_l = 0.25 * (tex_luma(x,y-1) + tex_luma(x-1,y) + tex_luma(x+1,y) + tex_luma(x,y+1));\n    float range_l = abs(luma_l - tex_luma(x, y));\n    // Get contrast range\n    vec2 range_min_max = fxaa_contrast(x, y);\n    float range = range_min_max.y - range_min_max.x;\n    float blend_l = max(0.0,\n    (range_l / range) - FXAA_SUBPIX_TRIM) * FXAA_SUBPIX_TRIM_SCALE;\n    blend_l = min(FXAA_SUBPIX_CAP, blend_l);\n    return blend_l;\n}\n\nvoid main() {\n    // Get texture size\n    texel = vec2(textureSize(preRender, 0)) * clipSpace;\n    vec4 original_color = fetch(0, 0);\n    float original_luma = tex_luma(0, 0);\n\n    mat3 luma = mat3(\n    vec3(tex_luma(-1,-1),tex_luma(0,-1),tex_luma(1,-1)),\n    vec3(tex_luma(-1, 0),tex_luma(0, 0),tex_luma(1, 0)),\n    vec3(tex_luma(-1, 1),tex_luma(0, 1),tex_luma(1, 1))\n    );\n\n    // Edge detection from NVIDIA FXAA white paper\n    float edge_vert =\n    abs((0.25 * luma[0].x) + (-0.5 * luma[0].y) + (0.25 * luma[0].z)) +\n    abs((0.50 * luma[1].x) + (-1.0 * luma[1].y) + (0.50 * luma[1].z)) +\n    abs((0.25 * luma[2].x) + (-0.5 * luma[2].y) + (0.25 * luma[2].z));\n\n    float edge_horz =\n    abs((0.25 * luma[0].x) + (-0.5 * luma[1].x) + (0.25 * luma[2].x)) +\n    abs((0.50 * luma[0].y) + (-1.0 * luma[1].y) + (0.50 * luma[2].y)) +\n    abs((0.25 * luma[0].z) + (-0.5 * luma[1].z) + (0.25 * luma[2].z));\n\n    bool horz_span = edge_horz >= edge_vert;\n    ivec2 step = ivec2(0, 1);\n    if (horz_span) step = ivec2(1, 0);\n\n    if (fxaa_is_low_contrast(0, 0)) {\n    out_color = original_color;\n    return;\n    }\n\n    ivec2 pos_n = - step;\n    ivec2 pos_p = step;\n    vec4 color = original_color;\n    float pixel_count = 1.0;\n    bool done_n = false;\n    bool done_p = false;\n\n    // Luma of neighbour with highest contrast\n    float luma_mcn = max(\n    max(abs(luma[0].y - luma[1].y), abs(luma[1].z - luma[1].y)),\n    max(abs(luma[2].y - luma[1].y), abs(luma[1].x - luma[1].y))\n    );\n\n    float gradient = abs(luma_mcn - luma[1].y);\n\n    for (int i = 0; i < FXAA_SEARCH_STEPS; i++) {\n    // Blend pixel with 3x3 box filter to preserve sub pixel detail\n    if (!done_n) {\n        vec4 local_blur_n = blur_3x3(pos_n.x, pos_n.y);\n        done_n = (abs(fxaa_luma(local_blur_n) - luma_mcn) >= gradient);\n        color += mix(fetch(pos_n.x, pos_n.y), local_blur_n, fxaa_sub_pixel_aliasing(pos_n.x, pos_n.y));\n        pixel_count++;\n        pos_n -= step;\n    } else if (!done_p) {\n        vec4 local_blur_p = blur_3x3(pos_p.x, pos_p.y);\n        done_p = (abs(fxaa_luma(local_blur_p) - luma_mcn) >= gradient);\n        color += mix(fetch(pos_p.x, pos_p.y), local_blur_p, fxaa_sub_pixel_aliasing(pos_p.x, pos_p.y));\n        pixel_count++;\n        pos_p += step;\n    } else {\n        break;\n    }\n    }\n    out_color = color / pixel_count;\n}",FXAA=class{textureIn;#canvas;#program;#tex;#vao;#vertexBuffer;#gl;constructor(e,t){this.#gl=e,this.#canvas=t,this.#program=GLLib.compile(e,GLLib.postVertex,fxaa_default),this.#vao=e.createVertexArray(),this.textureIn=e.createTexture(),e.bindVertexArray(this.#vao),e.useProgram(this.#program),this.#tex=e.getUniformLocation(this.#program,"preRender"),this.#vertexBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.#vertexBuffer),e.enableVertexAttribArray(0),e.vertexAttribPointer(0,2,e.FLOAT,!1,0,0),e.bindBuffer(e.ARRAY_BUFFER,this.#vertexBuffer),e.bufferData(e.ARRAY_BUFFER,Float32Array.from([0,0,1,0,0,1,1,1,0,1,1,0]),e.DYNAMIC_DRAW),this.createTexture()}createTexture=()=>{this.#gl.bindTexture(this.#gl.TEXTURE_2D,this.textureIn),this.#gl.texImage2D(this.#gl.TEXTURE_2D,0,this.#gl.RGBA,this.#canvas.width,this.#canvas.height,0,this.#gl.RGBA,this.#gl.UNSIGNED_BYTE,null),GLLib.setTexParams(this.#gl)};renderFrame=()=>{this.#gl.bindFramebuffer(this.#gl.FRAMEBUFFER,null),this.#gl.activeTexture(this.#gl.TEXTURE0),this.#gl.bindTexture(this.#gl.TEXTURE_2D,this.textureIn),this.#gl.useProgram(this.#program),this.#gl.bindVertexArray(this.#vao),this.#gl.uniform1i(this.#tex,0),this.#gl.drawArrays(this.#gl.TRIANGLES,0,6)}},taa_default="#version 300 es\nprecision highp float;\nin vec2 clipSpace;\nuniform sampler2D cache0;\nuniform sampler2D cache1;\nuniform sampler2D cache2;\nuniform sampler2D cache3;\nuniform sampler2D cache4;\nuniform sampler2D cache5;\nuniform sampler2D cache6;\nuniform sampler2D cache7;\nuniform sampler2D cache8;\nout vec4 outColor;\n\nvoid main () {\n    ivec2 texel = ivec2(vec2(textureSize(cache0, 0)) * clipSpace);\n\n    mat4 c0 = mat4(\n        texelFetch(cache1, texel, 0), \n        texelFetch(cache2, texel, 0),\n        texelFetch(cache3, texel, 0),\n        texelFetch(cache4, texel, 0)\n    );\n\n    mat4 c1 = mat4(\n        texelFetch(cache5, texel, 0), \n        texelFetch(cache6, texel, 0),\n        texelFetch(cache7, texel, 0),\n        texelFetch(cache8, texel, 0)\n    );\n\n    vec4 minRGB = vec4(1.0);\n    vec4 maxRGB = vec4(0.0);\n    \n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            vec4 p = texelFetch(cache0, texel + ivec2(i - 1, j - 1), 0);\n            minRGB = min(minRGB, p);\n            maxRGB = max(maxRGB, p);\n        }\n    }\n    \n    outColor = texelFetch(cache0, texel, 0);\n    for (int i = 0; i < 4; i++) outColor += min(max(c0[i], minRGB), maxRGB);\n    for (int i = 0; i < 4; i++) outColor += min(max(c1[i], minRGB), maxRGB);\n    outColor /= 9.0;\n}",FRAMES=9,TAA=class{textureIn;#program;#tex=new Array(FRAMES);#textures=new Array(FRAMES);#vao;#vertexBuffer;#gl;#canvas;frameIndex=0;#randomVecs;constructor(t,e){this.#gl=t,this.#canvas=e,this.#program=GLLib.compile(t,GLLib.postVertex,taa_default),this.#vao=t.createVertexArray(),this.textureIn=t.createTexture(),t.bindVertexArray(this.#vao),t.useProgram(this.#program);for(let e=0;e<FRAMES;e++)this.#textures[e]=t.createTexture();for(let e=0;e<FRAMES;e++)this.#tex[e]=t.getUniformLocation(this.#program,"cache"+e);this.#vertexBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.#vertexBuffer),t.enableVertexAttribArray(0),t.vertexAttribPointer(0,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.#vertexBuffer),t.bufferData(t.ARRAY_BUFFER,Float32Array.from([0,0,1,0,0,1,1,1,0,1,1,0]),t.DYNAMIC_DRAW),this.createTexture(),this.#randomVecs=this.genPseudoRandomVecsWith0Sum(FRAMES)}createTexture=()=>{this.#gl.bindTexture(this.#gl.TEXTURE_2D,this.textureIn),this.#gl.texImage2D(this.#gl.TEXTURE_2D,0,this.#gl.RGBA,this.#canvas.width,this.#canvas.height,0,this.#gl.RGBA,this.#gl.UNSIGNED_BYTE,null),GLLib.setTexParams(this.#gl);for(let e=0;e<FRAMES;e++)this.#gl.bindTexture(this.#gl.TEXTURE_2D,this.#textures[e]),this.#gl.texImage2D(this.#gl.TEXTURE_2D,0,this.#gl.RGBA,this.#canvas.width,this.#canvas.height,0,this.#gl.RGBA,this.#gl.UNSIGNED_BYTE,null),GLLib.setTexParams(this.#gl)};renderFrame=()=>{this.frameIndex=(this.frameIndex+1)%FRAMES,this.#textures.unshift(this.textureIn),this.textureIn=this.#textures.pop(),this.#gl.bindFramebuffer(this.#gl.FRAMEBUFFER,null);for(let e=0;e<FRAMES;e++)this.#gl.activeTexture(this.#gl.TEXTURE0+e),this.#gl.bindTexture(this.#gl.TEXTURE_2D,this.#textures[e]);this.#gl.useProgram(this.#program),this.#gl.bindVertexArray(this.#vao);for(let e=0;e<FRAMES;e++)this.#gl.uniform1i(this.#tex[e],e);this.#gl.drawArrays(this.#gl.TRIANGLES,0,6)};jitter=()=>{var e=(this.frameIndex+1)%FRAMES,t=.3/Math.min(this.#canvas.width,this.#canvas.height);return{x:this.#randomVecs[e][0]*t,y:this.#randomVecs[e][1]*t}};genPseudoRandomVecsWith0Sum=i=>{var n=new Array(i).fill(0).map(()=>new Array(2)),r=(n[0]=[0,1],n[1]=[1,0],[1,1]);for(let t=2;t<i;t++)for(let e=0;e<2;e++){var a=Math.max(-Math.min(t+1,i-1-t),r[e]-1),o=Math.min(Math.min(t+1,i-1-t),r[e]+1);n[t][e]=.5*(o+a+(o-a)*Math.sign(Math.random()-.5)*(.5*Math.random())**.5)-r[e],r[e]+=n[t][e]}return n}},pathtracer_vertex_default="#version 300 es\n#define TRIANGLES_PER_ROW_POWER 8\n#define TRIANGLES_PER_ROW 256\n#define INV_65535 0.000015259021896696422\n\nprecision highp int;\nprecision highp float;\nprecision highp sampler2D;\n\nin int triangleId;\nin int vertexId;\n\nlayout (std140) uniform transformMatrix\n{\n    mat3 rotation[MAX_TRANSFORMS];\n    vec3 shift[MAX_TRANSFORMS];\n};\n\nuniform vec3 cameraPosition;\nuniform mat3 viewMatrix;\n\n// Texture with vertex information about all triangles in scene\nuniform sampler2D geometryTex;\n\nout vec3 relativePosition;\nout vec3 absolutePosition;\nout vec2 uv;\nout vec3 clipSpace;\n\nflat out vec3 camera;\nflat out int initTriangleId;\nflat out int transformationId;\n\nconst vec2 baseUVs[3] = vec2[3](\n    vec2(1, 0), \n    vec2(0, 1), \n    vec2(0, 0)\n);\n\nvoid main() {\n    // Calculate vertex position in texture\n    int triangleColumn = triangleId >> TRIANGLES_PER_ROW_POWER;\n    ivec2 index = ivec2((triangleId - triangleColumn * TRIANGLES_PER_ROW) * 3, triangleColumn);\n\n    vec4 t0 = texelFetch(geometryTex, index, 0);\n    vec4 t1 = texelFetch(geometryTex, index + ivec2(1, 0), 0);\n    vec4 t2 = texelFetch(geometryTex, index + ivec2(2, 0), 0);\n\n    transformationId = int(t2.y);\n    // Apply local geometry transform\n    int tI = transformationId << 1;\n    // Combine vertex position\n    switch (vertexId) {\n        case 0:\n            relativePosition = t0.xyz;\n            break;\n        case 1:\n            relativePosition = vec3(t0.w, t1.xy);\n            break;\n        case 2:\n            relativePosition = vec3(t1.zw, t2.x);\n            break;\n    }\n    // Transform position\n    absolutePosition = rotation[tI] * relativePosition + shift[tI];\n    clipSpace = viewMatrix * (absolutePosition - cameraPosition);\n    // Set triangle position in clip space\n    gl_Position = vec4(clipSpace.xy, - 1.0f / (1.0f + exp(clipSpace.z * INV_65535)), clipSpace.z);\n\n    uv = baseUVs[vertexId];\n    camera = cameraPosition;\n    initTriangleId = triangleId;\n}",pathtracer_fragment_default="#version 300 es\n#define TRIANGLES_PER_ROW_POWER 8\n#define TRIANGLES_PER_ROW 256\n#define PI 3.141592653589793\n#define PHI 1.61803398874989484820459\n#define SQRT3 1.7320508075688772\n#define POW32 4294967296.0\n#define BIAS 0.0000152587890625\n#define THIRD 0.3333333333333333\n#define INV_PI 0.3183098861837907\n#define INV_256 0.00390625\n#define INV_255 0.00392156862745098\n#define INV_65536 0.0000152587890625\n\nprecision highp int;\nprecision highp float;\nprecision highp sampler2D;\n\nstruct Ray {\n    vec3 origin;\n    vec3 unitDirection;\n};\n\nstruct Material {\n    vec3 albedo;\n    vec3 rme;\n    vec3 tpo;\n};\n\nstruct Hit {\n    vec3 suv;\n    int transformId;\n    int triangleId;\n};\n\nin vec3 relativePosition;\nin vec3 absolutePosition;\nin vec2 uv;\nin vec3 clipSpace;\n\nflat in vec3 camera;\nflat in int initTriangleId;\nflat in int transformationId;\n\nlayout (std140) uniform transformMatrix\n{\n    mat3 rotation[MAX_TRANSFORMS];\n    vec3 shift[MAX_TRANSFORMS];\n};\n\n// Quality configurators\nuniform int samples;\nuniform int maxReflections;\nuniform float minImportancy;\nuniform int hdr;\nuniform int isTemporal;\n\n// Get global illumination color, intensity\nuniform vec3 ambient;\n\nuniform float randomSeed;\n// Textures in parallel for texture atlas\nuniform vec2 textureDims;\n\n// Texture with information about all triangles in scene\nuniform sampler2D geometryTex;\nuniform sampler2D sceneTex;\nuniform sampler2D translucencyTex;\nuniform sampler2D pbrTex;\nuniform sampler2D tex;\n\n// Texture with all primary light sources of scene\nuniform sampler2D lightTex;\n\nlayout(location = 0) out vec4 renderColor;\nlayout(location = 1) out vec4 renderColorIp;\nlayout(location = 2) out vec4 renderId;\n\nconst Hit NO_HIT = Hit(vec3(0.0), 0, -1);\n\n// Prevent blur over shadow border or over (close to) perfect reflections\nfloat firstRayLength = 1.0f;\n// Accumulate color of mirror reflections\n// float glassFilter = 0.0f;\nfloat originalRMEx = 0.0f;\nfloat originalTPOx = 0.0f;\nvec3 originalColor;\n\nfloat to4BitRepresentation(float a, float b) {\n    uint aui = uint(a * 255.0f) & uint(240);\n    uint bui = (uint(b * 255.0f) & uint(240)) >> 4;\n    return float(aui | bui) * INV_255;\n}\n\nfloat normalToSphearical4BitRepresentation(vec3 n) {\n    float phi = (atan(n.z, n.x) * INV_PI) * 0.5f + 0.5f;\n    float theta = (atan(n.x, n.y) * INV_PI) * 0.5f + 0.5f;\n    return to4BitRepresentation(phi, theta);\n}\n\nvec3 combineNormalRME(vec3 n, vec3 rme) {\n    return vec3(normalToSphearical4BitRepresentation(n), rme.x, to4BitRepresentation(rme.y, rme.z));\n}\n\n// Lookup values for texture atlases\nvec3 fetchTexVal(sampler2D atlas, vec2 uv, float texNum, vec3 defaultVal) {\n    if (texNum == - 1.0) return defaultVal;\n\n    vec2 atlasSize = vec2(textureSize(atlas, 0));\n    vec2 offset = vec2(\n        mod((textureDims.x * texNum), atlasSize.x),\n        floor((textureDims.x * texNum) / atlasSize.x) * textureDims.y\n    );\n    vec2 atlasCoords = (offset + uv * textureDims) / atlasSize;\n    // Return texel on requested location\n    return texture(atlas, atlasCoords).xyz;\n}\n\nvec4 noise(vec2 n, float seed) {\n    return fract(sin(dot(n.xy, vec2(12.9898f, 78.233f)) + vec4(53.0f, 59.0f, 61.0f, 67.0f) * (seed + randomSeed * PHI)) * 43758.5453f) * 2.0f - 1.0f;\n    // fract(sin(dot(n.xy, vec2<f32>(12.9898f, 78.233f)) + vec4<f32>(53.0f, 59.0f, 61.0f, 67.0f) * sin(seed + uniforms.temporal_target * PHI)) * 43758.5453f) * 2.0f - 1.0f;\n}\n\nvec3 moellerTrumbore(mat3 t, Ray ray, float l) {\n    vec3 edge1 = t[1] - t[0];\n    vec3 edge2 = t[2] - t[0];\n    vec3 pvec = cross(ray.unitDirection, edge2);\n    float det = dot(edge1, pvec);\n    if(abs(det) < BIAS) return vec3(0.0f);\n    float inv_det = 1.0f / det;\n    vec3 tvec = ray.origin - t[0];\n    float u = dot(tvec, pvec) * inv_det;\n    if(u < BIAS || u > 1.0f) return vec3(0.0f);\n    vec3 qvec = cross(tvec, edge1);\n    float v = dot(ray.unitDirection, qvec) * inv_det;\n    float uvSum = u + v;\n    if(v < BIAS || uvSum > 1.0f) return vec3(0.0f);\n    float s = dot(edge2, qvec) * inv_det;\n    if(s > l || s <= BIAS) return vec3(0.0f);\n    return vec3(s, u, v);\n}\n\n// Simplified Moeller-Trumbore algorithm for detecting only forward facing triangles\nbool moellerTrumboreCull(mat3 t, Ray ray, float l) {\n    vec3 edge1 = t[1] - t[0];\n    vec3 edge2 = t[2] - t[0];\n    vec3 pvec = cross(ray.unitDirection, edge2);\n    float det = dot(edge1, pvec);\n    float invDet = 1.0f / det;\n    if(det < BIAS) return false;\n    vec3 tvec = ray.origin - t[0];\n    float u = dot(tvec, pvec) * invDet;\n    if(u < BIAS || u > 1.0f) return false;\n    vec3 qvec = cross(tvec, edge1);\n    float v = dot(ray.unitDirection, qvec) * invDet;\n    if(v < BIAS || u + v > 1.0f) return false;\n    float s = dot(edge2, qvec) * invDet;\n    return (s <= l && s > BIAS);\n}\n\n// Don't return intersection point, because we're looking for a specific triangle not bounding box\nbool rayCuboid(float l, Ray ray, vec3 minCorner, vec3 maxCorner) {\n    vec3 v0 = (minCorner - ray.origin) / ray.unitDirection;\n    vec3 v1 = (maxCorner - ray.origin) / ray.unitDirection;\n    float tmin = max(max(min(v0.x, v1.x), min(v0.y, v1.y)), min(v0.z, v1.z));\n    float tmax = min(min(max(v0.x, v1.x), max(v0.y, v1.y)), max(v0.z, v1.z));\n    return tmax >= max(tmin, BIAS) && tmin < l;\n}\n\n// Test for closest ray triangle intersection\n// return intersection position in world space and index of target triangle in geometryTex\n// plus triangle and transformation Id\nHit rayTracer(Ray ray) {\n    // Cache transformed ray attributes\n    Ray tR = Ray(ray.origin, ray.unitDirection);\n    int cachedTI = 0;\n    // Latest intersection which is now closest to origin\n    Hit hit = NO_HIT;\n    // Length to latest intersection\n    float minLen = POW32;\n    // Get texture size as max iteration value\n    ivec2 geometryTexSize = textureSize(geometryTex, 0).xy;\n    int size = geometryTexSize.y * TRIANGLES_PER_ROW;\n    // Iterate through lines of texture\n    for(int i = 0; i < size; i++) {\n        // Get position of current triangle/vertex in geometryTex\n        int triangleColumn = i >> TRIANGLES_PER_ROW_POWER;\n        ivec2 index = ivec2((i - triangleColumn * TRIANGLES_PER_ROW) * 3, triangleColumn);\n        // Fetch triangle coordinates from scene graph\n        vec4 t0 = texelFetch(geometryTex, index, 0);\n        vec4 t1 = texelFetch(geometryTex, index + ivec2(1, 0), 0);\n        vec4 t2 = texelFetch(geometryTex, index + ivec2(2, 0), 0);\n\n        int tI = int(t2.y) << 1;\n        // Test if cached transformed variables are still valid\n        if (tI != cachedTI) {\n            int iI = tI + 1;\n            mat3 rotationII = rotation[iI];\n            cachedTI = tI;\n            tR = Ray(\n                rotationII * (ray.origin + shift[iI]),\n                rotationII * ray.unitDirection\n            );\n        }\n        // Three cases:\n        // t2.z = 0        => end of list: stop loop\n        // t2.z = 1        => is bounding volume: do AABB intersection test\n        // t2.z = 2        => is triangle: do triangle intersection test\n        if (t2.z == 0.0) return hit;\n\n        if (t2.z == 1.0) {\n            if (!rayCuboid(minLen, tR, t0.xyz, vec3(t0.w, t1.xy))) i += int(t1.z);\n        } else {\n            mat3 triangle = mat3 (t0, t1, t2.x);\n            // Test if triangle intersects ray\n            vec3 intersection = moellerTrumbore(triangle, tR, minLen);\n            // Test if ray even intersects\n            if(intersection.x != 0.0) {\n                // Calculate intersection point\n                hit = Hit(intersection, tI, i);\n                // Update maximum object distance for future rays\n                minLen = intersection.x;\n            }\n        }\n    }\n    // Return ray hit with all required information\n    return hit;\n}\n\n\n// Simplified rayTracer to only test if ray intersects anything\nbool shadowTest(Ray ray, float l) {\n    // Cache transformed ray attributes\n    Ray tR = Ray(ray.origin, ray.unitDirection);\n    int cachedTI = 0;\n    // Precompute max length\n    float minLen = l;\n    // Get texture size as max iteration value\n    int size = textureSize(geometryTex, 0).y * TRIANGLES_PER_ROW;\n    // Iterate through lines of texture\n    for(int i = 0; i < size; i++) {\n        // Get position of current triangle/vertex in geometryTex\n        int triangleColumn = i >> TRIANGLES_PER_ROW_POWER;\n        ivec2 index = ivec2((i - triangleColumn * TRIANGLES_PER_ROW) * 3, triangleColumn);\n        // Fetch triangle coordinates from scene graph\n        vec4 t0 = texelFetch(geometryTex, index, 0);\n        vec4 t1 = texelFetch(geometryTex, index + ivec2(1, 0), 0);\n        vec4 t2 = texelFetch(geometryTex, index + ivec2(2, 0), 0);\n\n        int tI = int(t2.y) << 1;\n        // Test if cached transformed variables are still valid\n        if (tI != cachedTI) {\n            int iI = tI + 1;\n            mat3 rotationII = rotation[iI];\n            cachedTI = tI;\n            tR = Ray(\n                rotationII * (ray.origin + shift[iI]),\n                normalize(rotationII * ray.unitDirection)\n            );\n        }\n        // Three cases:\n        // t2.z = 0        => end of list: stop loop\n        // t2.z = 1        => is bounding volume: do AABB intersection test\n        // t2.z = 2        => is triangle: do triangle intersection test\n        if (t2.z == 0.0) return false;\n\n        if (t2.z == 1.0) {\n            if (!rayCuboid(minLen, tR, t0.xyz, vec3(t0.w, t1.xy))) i += int(t1.z);\n        } else {\n            mat3 triangle = mat3 (t0, t1, t2.x);\n            // Test for triangle intersection in positive light ray direction\n            if (moellerTrumboreCull(triangle, tR, minLen)) return true;\n        }\n    }\n    // Tested all triangles, but there is no intersection\n    return false;\n}\n\nfloat trowbridgeReitz(float alpha, float NdotH) {\n    float numerator = alpha * alpha;\n    float denom = NdotH * NdotH * (numerator - 1.0f) + 1.0f;\n    return numerator / max(PI * denom * denom, BIAS);\n}\n\nfloat schlickBeckmann(float alpha, float NdotX) {\n    float k = alpha * 0.5f;\n    float denominator = NdotX * (1.0f - k) + k;\n    denominator = max(denominator, BIAS);\n    return NdotX / denominator;\n}\n\nfloat smith(float alpha, float NdotV, float NdotL) {\n    return schlickBeckmann(alpha, NdotV) * schlickBeckmann(alpha, NdotL);\n}\n\nvec3 fresnel(vec3 F0, float theta) {\n    // Use Schlick approximation\n    return F0 + (1.0f - F0) * pow(1.0f - theta, 5.0f);\n}\n\nvec3 forwardTrace(Material material, vec3 lightDir, float strength, vec3 N, vec3 V) {\n    float lenP1 = 1.0f + length(lightDir);\n    // Apply inverse square law\n    float brightness = strength / (lenP1 * lenP1);\n\n    vec3 L = normalize(lightDir);\n    vec3 H = normalize(V + L);\n\n    float VdotH = max(dot(V, H), 0.0f);\n    float NdotL = max(dot(N, L), 0.0f);\n    float NdotH = max(dot(N, H), 0.0f);\n    float NdotV = max(dot(N, V), 0.0f);\n\n    float alpha = material.rme.x * material.rme.x;\n    float BRDF = mix(1.0f, NdotV, material.rme.y);\n    vec3 F0 = material.albedo * BRDF;\n\n    vec3 Ks = fresnel(F0, VdotH);\n    vec3 Kd = (1.0f - Ks) * (1.0f - material.rme.y);\n    vec3 lambert = material.albedo * INV_PI;\n\n    vec3 cookTorranceNumerator = Ks * trowbridgeReitz(alpha, NdotH) * smith(alpha, NdotV, NdotL);\n    float cookTorranceDenominator = 4.0f * NdotV * NdotL;\n    cookTorranceDenominator = max(cookTorranceDenominator, BIAS);\n\n    vec3 cookTorrance = cookTorranceNumerator / cookTorranceDenominator;\n    vec3 radiance = Kd * lambert + cookTorrance;\n\n    // Outgoing light to camera\n    return radiance * NdotL * brightness;\n}\n\n/*\nvec3 referenceSample (sampler2D lightTex, vec4 randomVec, vec3 N, vec3 target, vec3 V, Material material, bool dontFilter, int triangleId, int i) {\n    vec3 localColor = vec3(0);\n    int lights = textureSize(lightTex, 0).y;\n\n    for (int j = 0; j < lights; j++) {\n        // Read light position\n        vec3 light = texelFetch(lightTex, ivec2(0, j), 0).xyz;\n        // Read light strength from texture\n        vec2 strengthVariation = texelFetch(lightTex, ivec2(1, j), 0).xy;\n        // Skip if strength is negative or zero\n        // if (strengthVariation.x <= 0.0) continue;\n        // Alter light source position according to variation.\n        light = randomVec.xyz * strengthVariation.y + light;\n        vec3 lightDir = light - target;\n        vec3 lightColor = forwardTrace(lightDir, N, V, material, strengthVariation.x);\n        // Compute quick exit criterion to potentially skip expensive shadow test\n        bool quickExitCriterion = dot(lightDir, N) <= BIAS;\n        Ray lightRay = Ray(light, target, lightDir, normalize(lightDir));\n        // Test if in shadow\n        if (quickExitCriterion || shadowTest(lightRay, triangleId)) {\n            if (dontFilter || i == 0) renderId.w = float(((j % 128) << 1) + 1) * INV_255;\n        } else {\n            if (dontFilter || i == 0) renderId.w = float((j % 128) << 1) * INV_255;\n            // localColor *= (totalWeight / reservoirLength) / reservoirWeight;\n            localColor += lightColor;\n        }\n    }\n\n    return localColor + material.rme.z + ambient * material.rme.y;\n}\n\n\nvec3 randomSample (vec4 randomVec, vec3 N, vec3 smoothNormal, vec3 target,  vec3 V, Material material, bool dontFilter, int triangleId, int i) {\n    int lights = textureSize(lightTex, 0).y;\n\n    int randIndex = int(floor(abs(randomVec.y) * float(lights)));\n\n    \n    // Read light position\n    vec3 light = texelFetch(lightTex, ivec2(0, randIndex), 0).xyz;\n    // Read light strength from texture\n    vec2 strengthVariation = texelFetch(lightTex, ivec2(1, randIndex), 0).xy;\n    // Skip if strength is negative or zero\n    // if (strengthVariation.x <= 0.0) continue;\n    // Alter light source position according to variation.\n    light = randomVec.xyz * strengthVariation.y + light;\n    vec3 lightDir = light - target;\n    vec3 lightColor = forwardTrace(material, lightDir, strengthVariation.x, N, V);\n    // Compute quick exit criterion to potentially skip expensive shadow test\n    bool quickExitCriterion = dot(lightDir, N) <= BIAS;\n    // Ray lightRay = Ray(light, target, lightDir, normalize(lightDir));\n    Ray lightRay = Ray(target, light, lightDir, normalize(lightDir));\n    // Test if in shadow\n    if (quickExitCriterion || shadowTest(lightRay, triangleId)) {\n        if (dontFilter || i == 0) renderId.w = float(((randIndex % 128) << 1) + 1) * INV_255;\n        return vec3(material.rme.z);\n    } else {\n        if (dontFilter || i == 0) renderId.w = float((randIndex % 128) << 1) * INV_255;\n        return lightColor * float(lights) + material.rme.z;\n    }\n}\n*/\n\nvec3 reservoirSample (Material material, Ray ray, vec4 randomVec, vec3 N, vec3 smoothNormal, float geometryOffset, bool dontFilter, int i) {\n    vec3 localColor = vec3(0);\n    float reservoirLength = 0.0f;\n    float totalWeight = 0.0f;\n    int reservoirNum = 0;\n    float reservoirWeight = 0.0f;\n    vec3 reservoirLight;\n    vec3 reservoirLightDir;\n    vec2 lastRandom = noise(randomVec.zw, BIAS).xy;\n\n    int size = textureSize(lightTex, 0).y;\n    for (int j = 0; j < size; j++) {\n      // Read light strength from texture\n      vec2 strengthVariation = texelFetch(lightTex, ivec2(1, j), 0).xy;\n      // Skip if strength is negative or zero\n      if (strengthVariation.x <= 0.0) continue;\n      // Increment light weight\n      reservoirLength ++;\n      // Alter light source position according to variation.\n      vec3 light = texelFetch(lightTex, ivec2(0, j), 0).xyz + randomVec.xyz * strengthVariation.y;\n      vec3 dir = light - ray.origin;\n    \n      vec3 colorForLight = forwardTrace(material, dir, strengthVariation.x, N, - ray.unitDirection);\n      localColor += colorForLight;\n      float weight = length(colorForLight);\n      totalWeight += weight;\n      if (abs(lastRandom.y) * totalWeight <= weight) {\n        reservoirNum = j;\n        reservoirWeight = weight;\n        reservoirLight = light;\n        reservoirLightDir = dir;\n      }\n      // Update pseudo random variable.\n      lastRandom = noise(lastRandom, BIAS).zw;\n    }\n\n    vec3 unitLightDir = normalize(reservoirLightDir);\n    // Compute quick exit criterion to potentially skip expensive shadow test\n    bool showColor = reservoirLength == 0.0 || reservoirWeight == 0.0;\n    bool showShadow = dot(smoothNormal, unitLightDir) <= BIAS;\n    // Apply emissive texture and ambient light\n    vec3 baseLuminance = vec3(material.rme.z) * material.albedo;\n    // Update filter\n    if (dontFilter || i == 0) renderId.w = float((reservoirNum % 128) << 1) * INV_255;\n    // Test if in shadow\n    if (showColor) return localColor + baseLuminance;\n\n    if (showShadow) {\n        if (dontFilter || i == 0) renderId.w += INV_255;\n        return baseLuminance;\n    }\n    // Apply geometry offset\n    vec3 offsetTarget = ray.origin + geometryOffset * smoothNormal;\n    Ray lightRay = Ray(offsetTarget, unitLightDir);\n\n    if (shadowTest(lightRay, length(reservoirLightDir))) {\n        if (dontFilter || i == 0) renderId.w += INV_255;\n        return baseLuminance;\n    } else {\n        return localColor + baseLuminance;\n    }\n}\n\n\nvec3 lightTrace(Hit hit, vec3 target, vec3 camera, float cosSampleN, int bounces) {\n    // Set bool to false when filter becomes necessary\n    bool dontFilter = true;\n    // Use additive color mixing technique, so start with black\n    vec3 finalColor = vec3(0);\n    vec3 importancyFactor = vec3(1);\n    vec3 filterFactor = vec3(1);\n    originalColor = vec3(1);\n\n    Ray ray = Ray(camera, normalize(target - camera));\n    vec3 lastHitPoint = camera;\n    // Iterate over each bounce and modify color accordingly\n    for (int i = 0; i < bounces && length(filterFactor) >= minImportancy * SQRT3; i++) {\n        float fi = float(i);\n        mat3 rTI = rotation[hit.transformId];\n        vec3 sTI = shift[hit.transformId];\n        // Transform hit point\n        ray.origin = hit.suv.x * ray.unitDirection + ray.origin;\n        // Calculate barycentric coordinates\n        vec3 uvw = vec3(1.0 - hit.suv.y - hit.suv.z, hit.suv.y, hit.suv.z);\n\n        // Get position of current triangle/vertex in sceneTex\n        int triangleColumn = hit.triangleId >> TRIANGLES_PER_ROW_POWER;\n        // Fetch triangle coordinates from scene graph texture\n        ivec2 indexGeometry = ivec2((hit.triangleId - triangleColumn * TRIANGLES_PER_ROW) * 3, triangleColumn);\n        vec4 g0 = texelFetch(geometryTex, indexGeometry, 0);\n        vec4 g1 = texelFetch(geometryTex, indexGeometry + ivec2(1, 0), 0);\n        vec4 g2 = texelFetch(geometryTex, indexGeometry + ivec2(2, 0), 0);\n\n        mat3 triangle = rTI * mat3(g0, g1, g2.x);\n        vec3 offsetRayTarget = ray.origin - sTI;\n\n        vec3 geometryNormal = normalize(cross(triangle[0] - triangle[1], triangle[0] - triangle[2]));\n        vec3 diffs = vec3(\n            distance(offsetRayTarget, triangle[0]),\n            distance(offsetRayTarget, triangle[1]),\n            distance(offsetRayTarget, triangle[2])\n        );\n        // Fetch scene texture data\n        ivec2 indexScene = ivec2((hit.triangleId - triangleColumn * TRIANGLES_PER_ROW) * 7, triangleColumn);\n        // Fetch texture data\n        vec4 t0 = texelFetch(sceneTex, indexScene, 0);\n        vec4 t1 = texelFetch(sceneTex, indexScene + ivec2(1, 0), 0);\n        vec4 t2 = texelFetch(sceneTex, indexScene + ivec2(2, 0), 0);\n        vec4 t3 = texelFetch(sceneTex, indexScene + ivec2(3, 0), 0);\n        vec4 t4 = texelFetch(sceneTex, indexScene + ivec2(4, 0), 0);\n        vec4 t5 = texelFetch(sceneTex, indexScene + ivec2(5, 0), 0);\n        vec4 t6 = texelFetch(sceneTex, indexScene + ivec2(6, 0), 0);\n        // Pull normals\n        mat3 normals = rTI * mat3(t0, t1, t2.x);\n        // Interpolate smooth normal\n        vec3 smoothNormal = normalize(normals * uvw);\n        // to prevent unnatural hard shadow / reflection borders due to the difference between the smooth normal and geometry\n        vec3 angles = acos(abs(geometryNormal * normals));\n        vec3 angleTan = clamp(tan(angles), 0.0, 1.0);\n        float geometryOffset = dot(diffs * angleTan, uvw);\n        // Interpolate final barycentric texture coordinates between UV's of the respective vertices\n        vec2 barycentric = mat3x2(t2.yzw, t3.xyz) * uvw;\n        // Gather material attributes (albedo, roughness, metallicity, emissiveness, translucency, partical density and optical density aka. IOR) out of world texture\n        Material material = Material(\n            fetchTexVal(tex, barycentric, t3.w, vec3(t4.zw, t5.x)),\n            fetchTexVal(pbrTex, barycentric, t4.x, t5.yzw),\n            fetchTexVal(translucencyTex, barycentric, t4.y, t6.xyz)\n        );\n        \n        ray = Ray(ray.origin, normalize(ray.origin - lastHitPoint));\n        // If ray reflects from inside or onto an transparent object,\n        // the surface faces in the opposite direction as usual\n        float signDir = sign(dot(ray.unitDirection, smoothNormal));\n        smoothNormal *= - signDir;\n\n        // Generate pseudo random vector\n        vec4 randomVec = noise(clipSpace.xy * length(ray.origin - lastHitPoint), fi + cosSampleN * PHI);\n        vec3 randomSpheareVec = normalize(smoothNormal + normalize(randomVec.xyz));\n        float BRDF = mix(1.0f, abs(dot(smoothNormal, ray.unitDirection)), material.rme.y);\n\n        // Alter normal according to roughness value\n        float roughnessBRDF = material.rme.x * BRDF;\n        vec3 roughNormal = normalize(mix(smoothNormal, randomSpheareVec, roughnessBRDF));\n\n        vec3 H = normalize(roughNormal - ray.unitDirection);\n        float VdotH = max(dot(- ray.unitDirection, H), 0.0f);\n        vec3 F0 = material.albedo * BRDF;\n        vec3 f = fresnel(F0, VdotH);\n\n        float fresnelReflect = max(f.x, max(f.y, f.z));\n        // object is solid or translucent by chance because of the fresnel effect\n        bool isSolid = material.tpo.x * fresnelReflect <= abs(randomVec.w);\n\n        // Determine local color considering PBR attributes and lighting\n        vec3 localColor = reservoirSample(material, ray, randomVec, - signDir * roughNormal, - signDir * smoothNormal, geometryOffset, dontFilter, i);\n        // Calculate primary light sources for this pass if ray hits non translucent object\n        finalColor += localColor * importancyFactor;\n        // Multiply albedo with either absorption value or filter colo\n        if (dontFilter) {\n            originalColor *= (material.albedo + INV_255);\n            finalColor /= (material.albedo + INV_255);\n            \n            // importancyFactor /= material.albedo;\n            // importancyFactor *= material.albedo;\n            // Update last used tpo.x value\n            originalTPOx = material.tpo.x;\n            // Add filtering intensity for respective surface\n            originalRMEx += material.rme.x;\n            // Update render id\n            vec4 renderIdUpdate = pow(2.0f, - fi) * vec4(combineNormalRME(smoothNormal, material.rme), 0.0f);\n\n            renderId += renderIdUpdate;\n            // if (i == 0) renderOriginalId += renderIdUpdate;\n            // Test if filter is already necessary\n            dontFilter = (material.rme.x < 0.01f && isSolid) || !isSolid;\n\n            if(isSolid && material.tpo.x > 0.01f) {\n                // glassFilter += 1.0f;\n                dontFilter = false;\n            }\n            \n        } else {\n            importancyFactor *= material.albedo;\n        }\n\n        filterFactor *= material.albedo;\n        // Update length of first fector to control blur intensity\n        if (i == 1) firstRayLength = min(length(ray.origin - lastHitPoint) / length(lastHitPoint - camera), firstRayLength);\n\n        // Handle translucency and skip rest of light calculation\n        if(isSolid) {\n            // Calculate reflecting ray\n            ray.unitDirection = normalize(mix(reflect(ray.unitDirection, smoothNormal), randomSpheareVec, roughnessBRDF));\n        } else {\n            float eta = mix(1.0f / material.tpo.z, material.tpo.z, max(signDir, 0.0f));\n            // Refract ray depending on IOR (material.tpo.z)\n            ray.unitDirection = normalize(mix(refract(ray.unitDirection, smoothNormal, eta),randomSpheareVec, roughnessBRDF));\n        }\n        // Calculate next intersection\n        hit = rayTracer(ray);\n        // Stop loop if there is no intersection and ray goes in the void\n        if (hit.triangleId == - 1) break;\n        // Update other parameters\n        lastHitPoint = ray.origin;\n    }\n    // Return final pixel color\n    return finalColor + importancyFactor * ambient;\n}\n\nvoid main() {\n    // Transform normal according to object transform\n    int tI = transformationId << 1;\n    vec3 uvw = vec3(uv, 1.0f - uv.x - uv.y);\n    // Generate hit struct for pathtracer\n    Hit hit = Hit(vec3(distance(absolutePosition, camera), uvw.yz), tI, initTriangleId);\n    // vec3 finalColor = material.rme;\n    vec3 finalColor = vec3(0);\n    // Generate multiple samples\n    for(int i = 0; i < samples; i++) {\n        // Use cosine as noise in random coordinate picker\n        float cosSampleN = cos(float(i));\n        finalColor += lightTrace(hit, absolutePosition, camera, cosSampleN, maxReflections);\n    }\n    // Average ray colors over samples.\n    float invSamples = 1.0f / float(samples);\n    finalColor *= invSamples;\n\n    /*if(useFilter == 1) {\n        // Render all relevant information to 4 textures for the post processing shader\n        renderColor = vec4(fract(finalColor), 1.0f);\n        // 16 bit HDR for improved filtering\n        renderColorIp = vec4(floor(finalColor) * INV_255, glassFilter);\n    } else {\n    */\n    finalColor *= originalColor;\n\n    if (isTemporal == 0 && hdr == 1) {\n        // Apply Reinhard tone mapping\n        finalColor = finalColor / (finalColor + vec3(1.0f));\n        // Gamma correction\n        // float gamma = 0.8f;\n        // finalColor = pow(4.0f * finalColor, vec3(1.0f / gamma)) / 4.0f * 1.3f;\n    }\n\n\n    if (isTemporal == 1) {\n        renderColor = vec4(fract(finalColor), 1.0f);\n        // 16 bit HDR for improved filtering\n        renderColorIp = vec4(floor(finalColor) * INV_255, 1.0f);\n    } else {\n        renderColor = vec4(finalColor, 1.0f);\n    }\n    //}\n    /*\n    \n    */\n    // render normal (last in transparency)\n    renderId += vec4(0.0f, 0.0f, 0.0f, INV_255);\n    // render modulus of absolute position (last in transparency)´\n    // renderColor = vec4(smoothNormal, 1.0);\n    // renderColorIp = vec4(0.0);\n}",PathtracingUniformLocationIdentifiers=["cameraPosition","viewMatrix","samples","maxReflections","minImportancy","hdr","isTemporal","ambient","randomSeed","textureDims","geometryTex","sceneTex","pbrTex","translucencyTex","tex","lightTex"],PathtracingUniformFunctionTypes=["uniform3f","uniformMatrix3fv","uniform1i","uniform1i","uniform1f","uniform1i","uniform1i","uniform3f","uniform1f","uniform2f","uniform1i","uniform1i","uniform1i","uniform1i","uniform1i","uniform1i"],PathTracerWGL2=class{type="pathtracer";config;fps=0;fpsLimit=1/0;#antialiasing;#AAObject;#gl;#canvas;#geometryTexture;#sceneTexture;#triangleIdBufferArray;#bufferLength;#textureAtlas;#pbrAtlas;#translucencyAtlas;#textureList=[];#pbrList=[];#translucencyList=[];#lightTexture;#tempGlsl;#engineState={};#resizeEvent;#halt=!0;constructor(e,t,i,n){this.#canvas=e,this.camera=i,this.scene=t,this.config=n,this.#gl=e.getContext("webgl2")}halt=()=>{try{this.#gl.loseContext()}catch(e){console.warn("Unable to lose previous context, reload page in case of performance issue")}this.#halt=!0,window.removeEventListener("resize",this.#resizeEvent)};get canvas(){return this.#canvas}async#updateAtlas(e){if(0===e.length)this.#gl.texImage2D(this.#gl.TEXTURE_2D,0,this.#gl.RGBA,1,1,0,this.#gl.RGBA,this.#gl.UNSIGNED_BYTE,new Uint8Array(4));else{let[i,n]=this.scene.standardTextureSizes,r=Math.floor(2048/i);var t=document.createElement("canvas");let a=t.getContext("2d");t.width=Math.min(i*e.length,2048),t.height=n*(Math.floor(i*e.length/2048)+1),a.imageSmoothingEnabled=!1,e.forEach(async(e,t)=>a.drawImage(e,i*(t%r),n*Math.floor(t/r),i,n)),this.#gl.texImage2D(this.#gl.TEXTURE_2D,0,this.#gl.RGBA,this.#gl.RGBA,this.#gl.UNSIGNED_BYTE,t)}}async#updateTextureAtlas(){this.scene.textures.length===this.#textureList.length&&this.scene.textures.every((e,t)=>e===this.#textureList[t])||(this.#textureList=this.scene.textures,this.#gl.bindTexture(this.#gl.TEXTURE_2D,this.#textureAtlas),this.#gl.pixelStorei(this.#gl.UNPACK_ALIGNMENT,1),GLLib.setTexParams(this.#gl),this.#updateAtlas(this.scene.textures))}async#updatePbrAtlas(){this.scene.pbrTextures.length===this.#pbrList.length&&this.scene.pbrTextures.every((e,t)=>e===this.#pbrList[t])||(this.#pbrList=this.scene.pbrTextures,this.#gl.bindTexture(this.#gl.TEXTURE_2D,this.#pbrAtlas),this.#gl.pixelStorei(this.#gl.UNPACK_ALIGNMENT,1),GLLib.setTexParams(this.#gl),this.#updateAtlas(this.scene.pbrTextures))}async#updateTranslucencyAtlas(){this.scene.translucencyTextures.length===this.#translucencyList.length&&this.scene.translucencyTextures.every((e,t)=>e===this.#translucencyList[t])||(this.#translucencyList=this.scene.translucencyTextures,this.#gl.bindTexture(this.#gl.TEXTURE_2D,this.#translucencyAtlas),this.#gl.pixelStorei(this.#gl.UNPACK_ALIGNMENT,1),GLLib.setTexParams(this.#gl),this.#updateAtlas(this.scene.translucencyTextures))}async updatePrimaryLightSources(){if(this.#gl.bindTexture(this.#gl.TEXTURE_2D,this.#lightTexture),this.#gl.pixelStorei(this.#gl.UNPACK_ALIGNMENT,1),GLLib.setTexParams(this.#gl),0===this.scene.primaryLightSources.length)this.#gl.texImage2D(this.#gl.TEXTURE_2D,0,this.#gl.RGB32F,2,1,0,this.#gl.RGB,this.#gl.FLOAT,Float32Array.from([0,0,0,0,0,0]));else{var e,t,i,n=[];for(e of this.scene.primaryLightSources)e&&(t=e.intensity??this.scene.defaultLightIntensity,i=e.variation??this.scene.defaultLightVariation,n.push(e[0],e[1],e[2],t,i,0));this.#gl.texImage2D(this.#gl.TEXTURE_2D,0,this.#gl.RGB32F,2,this.scene.primaryLightSources.length,0,this.#gl.RGB,this.#gl.FLOAT,Float32Array.from(n))}}async updateScene(){var e=await this.scene.generateArraysFromGraph();this.#bufferLength=e.bufferLength,this.#triangleIdBufferArray=e.idBuffer,this.#gl.bindTexture(this.#gl.TEXTURE_2D,this.#geometryTexture),this.#gl.pixelStorei(this.#gl.UNPACK_ALIGNMENT,4),GLLib.setTexParams(this.#gl),this.#gl.texImage2D(this.#gl.TEXTURE_2D,0,this.#gl.RGBA32F,768,e.geometryBufferHeight,0,this.#gl.RGBA,this.#gl.FLOAT,e.geometryBuffer),this.#gl.bindTexture(this.#gl.TEXTURE_2D,this.#sceneTexture),GLLib.setTexParams(this.#gl),this.#gl.pixelStorei(this.#gl.UNPACK_ALIGNMENT,4),this.#gl.texImage2D(this.#gl.TEXTURE_2D,0,this.#gl.RGBA32F,1792,e.sceneBufferHeight,0,this.#gl.RGBA,this.#gl.FLOAT,e.sceneBuffer)}async render(){this.#halt=!1;let a,n,r,o,s,l,c,u,h,f;let t=this.#gl.createTexture(),i=this.#gl.createTexture(),m=this.#gl.createTexture(),d=this.#gl.createTexture(),g,p,v,_,x,y,b=this.#gl.createVertexArray(),T=this.#gl.createVertexArray(),A=()=>{if(!this.#halt){var e=performance.now();if(this.#updateTextureAtlas(),this.#updatePbrAtlas(),this.#updateTranslucencyAtlas(),this.updatePrimaryLightSources(),this.#engineState.temporal!==this.config.temporal||this.#engineState.temporalSamples!==this.config.temporalSamples||this.#engineState.renderQuality!==this.config.renderQuality)requestAnimationFrame(()=>S());else{if(this.#engineState.antialiasing!==this.config.antialiasing){this.#engineState.antialiasing=this.config.antialiasing;var t=this.config.antialiasing.toLowerCase();switch(t){case"fxaa":this.#antialiasing=t,this.#AAObject=new FXAA(this.#gl,this.#canvas);break;case"taa":this.#antialiasing=t,this.#AAObject=new TAA(this.#gl,this.#canvas);break;default:this.#antialiasing=void 0,this.#AAObject=void 0}}R(this.#engineState),this.#engineState.intermediateFrames++,this.#engineState.temporalFrame=(this.#engineState.temporalFrame+1)%2048;var i=e-this.#engineState.lastTimeStamp;500<i&&(this.fps=(1e3*this.#engineState.intermediateFrames/i).toFixed(0),this.#engineState.lastTimeStamp=e,this.#engineState.intermediateFrames=0),setTimeout(function(){requestAnimationFrame(()=>A())},1e3/this.fpsLimit)}}},e=()=>{let e={x:0,y:0};this.#AAObject&&"taa"===this.#antialiasing&&(e=this.#AAObject.jitter());var t={x:this.camera.direction.x+e.x,y:this.camera.direction.y+e.y},i=1/this.camera.fov,n=this.#canvas.height*i/this.#canvas.width,n=[Math.cos(t.x)*n,0,Math.sin(t.x)*n,-Math.sin(t.x)*Math.sin(t.y)*i,Math.cos(t.y)*i,Math.cos(t.x)*Math.sin(t.y)*i,-Math.sin(t.x)*Math.cos(t.y),-Math.sin(t.y),Math.cos(t.x)*Math.cos(t.y)];this.#gl.bindVertexArray(b),this.#gl.useProgram(a),[this.#geometryTexture,this.#sceneTexture,this.#pbrAtlas,this.#translucencyAtlas,this.#textureAtlas,this.#lightTexture].forEach((e,t)=>{this.#gl.activeTexture(this.#gl.TEXTURE0+t),this.#gl.bindTexture(this.#gl.TEXTURE_2D,e)});let r=[[this.camera.position.x,this.camera.position.y,this.camera.position.z],[!0,n],[this.config.samplesPerRay],[this.config.maxReflections],[this.config.minImportancy],[this.config.hdr],[this.config.temporal],this.scene.ambientLight,[this.config.temporal?this.#engineState.temporalFrame:0],this.scene.standardTextureSizes,[0],[1],[2],[3],[4],[5]];PathtracingUniformFunctionTypes.forEach((e,t)=>this.#gl[e](this.#engineState.pathtracingUniformLocations[t],...r[t])),this.#gl.bindBuffer(this.#gl.UNIFORM_BUFFER,l);i=Transform.buildWGL2Arrays();this.#gl.bufferSubData(this.#gl.UNIFORM_BUFFER,u[0],i.rotationBuffer,0),this.#gl.bufferSubData(this.#gl.UNIFORM_BUFFER,u[1],i.shiftBuffer,0),this.#gl.bindBuffer(this.#gl.UNIFORM_BUFFER,null),this.#gl.bindBuffer(this.#gl.ARRAY_BUFFER,o),this.#gl.bufferData(this.#gl.ARRAY_BUFFER,this.#triangleIdBufferArray,this.#gl.DYNAMIC_DRAW),this.#gl.bindBuffer(this.#gl.ARRAY_BUFFER,s),this.#gl.bufferData(this.#gl.ARRAY_BUFFER,new Int32Array([0,1,2]),this.#gl.STATIC_DRAW),this.#gl.drawArraysInstanced(this.#gl.TRIANGLES,0,3,this.#bufferLength)},R=()=>{if((this.config.temporal||this.#antialiasing)&&(this.#gl.bindFramebuffer(this.#gl.FRAMEBUFFER,h),this.#gl.drawBuffers([this.#gl.COLOR_ATTACHMENT0,this.#gl.COLOR_ATTACHMENT1,this.#gl.COLOR_ATTACHMENT2]),this.config.temporal?(g.unshift(g.pop()),p.unshift(p.pop()),v.unshift(v.pop()),this.#gl.framebufferTexture2D(this.#gl.FRAMEBUFFER,this.#gl.COLOR_ATTACHMENT0,this.#gl.TEXTURE_2D,g[0],0),this.#gl.framebufferTexture2D(this.#gl.FRAMEBUFFER,this.#gl.COLOR_ATTACHMENT1,this.#gl.TEXTURE_2D,p[0],0),this.#gl.framebufferTexture2D(this.#gl.FRAMEBUFFER,this.#gl.COLOR_ATTACHMENT2,this.#gl.TEXTURE_2D,v[0],0)):this.#antialiasing&&this.#gl.framebufferTexture2D(this.#gl.FRAMEBUFFER,this.#gl.COLOR_ATTACHMENT0,this.#gl.TEXTURE_2D,this.#AAObject.textureIn,0),this.#gl.framebufferTexture2D(this.#gl.FRAMEBUFFER,this.#gl.DEPTH_ATTACHMENT,this.#gl.TEXTURE_2D,m,0)),this.#gl.clear(this.#gl.COLOR_BUFFER_BIT|this.#gl.DEPTH_BUFFER_BIT),e(),this.config.temporal){this.#antialiasing?(this.#gl.bindFramebuffer(this.#gl.FRAMEBUFFER,f),this.#gl.drawBuffers([this.#gl.COLOR_ATTACHMENT0]),this.#gl.framebufferTexture2D(this.#gl.FRAMEBUFFER,this.#gl.COLOR_ATTACHMENT0,this.#gl.TEXTURE_2D,this.#AAObject.textureIn,0)):this.#gl.bindFramebuffer(this.#gl.FRAMEBUFFER,null),[...g,...p,...v].forEach((e,t)=>{this.#gl.activeTexture(this.#gl.TEXTURE0+t),this.#gl.bindTexture(this.#gl.TEXTURE_2D,e)}),this.#gl.bindVertexArray(T),this.#gl.useProgram(n),this.#gl.uniform1i(r,this.config.hdr);for(let e=0;e<this.config.temporalSamples;e++)this.#gl.uniform1i(_[e],e),this.#gl.uniform1i(x[e],this.config.temporalSamples+e),this.#gl.uniform1i(y[e],2*this.config.temporalSamples+e);this.#gl.drawArrays(this.#gl.TRIANGLES,0,6)}this.#antialiasing&&this.#AAObject.renderFrame()},S=()=>{this.halt(),this.#halt=!1,Object.assign(this.#engineState,{intermediateFrames:0,lastTimeStamp:performance.now(),temporal:this.config.temporal,temporalFrame:0,temporalSamples:this.config.temporalSamples,renderQuality:this.config.renderQuality,bufferLength:0});var i=`
      `;this.#tempGlsl=`#version 300 es
      precision highp float;
      in vec2 clipSpace;
      uniform int hdr;
      `;for(let e=0;e<this.config.temporalSamples;e++)this.#tempGlsl+="uniform sampler2D cache"+e+";"+i,this.#tempGlsl+="uniform sampler2D cacheIp"+e+";"+i,this.#tempGlsl+="uniform sampler2D cacheId"+e+";"+i;this.#tempGlsl+=`
      layout(location = 0) out vec4 renderColor;
      `,this.#tempGlsl+=`void main () {
        ivec2 texel = ivec2(vec2(textureSize(cache0, 0)) * clipSpace);
        vec4 id = texelFetch(cacheId0, texel, 0);
        float counter = 1.0;

        vec3 color = texelFetch(cache0, texel, 0).xyz + texelFetch(cacheIp0, texel, 0).xyz * 256.0;
      `;for(let t=1;t<this.config.temporalSamples;t+=4){this.#tempGlsl+="mat4 c"+t+" = mat4(";for(let e=t;e<t+3;e++)this.#tempGlsl+=(e<this.config.temporalSamples?"texelFetch(cache"+e+", texel, 0),":"vec4(0),")+i;this.#tempGlsl+=(t+3<this.config.temporalSamples?"texelFetch(cache"+(t+3)+", texel, 0) "+i+" ); ":"vec4(0) "+i+"); ")+i,this.#tempGlsl+="mat4 ip"+t+" = mat4(";for(let e=t;e<t+3;e++)this.#tempGlsl+=(e<this.config.temporalSamples?"texelFetch(cacheIp"+e+", texel, 0),":"vec4(0),")+i;this.#tempGlsl+=(t+3<this.config.temporalSamples?"texelFetch(cacheIp"+(t+3)+", texel, 0) "+i+"); ":"vec4(0) "+i+"); ")+i,this.#tempGlsl+="mat4 id"+t+" = mat4(";for(let e=t;e<t+3;e++)this.#tempGlsl+=(e<this.config.temporalSamples?"texelFetch(cacheId"+e+", texel, 0),":"vec4(0),")+i;this.#tempGlsl+=(t+3<this.config.temporalSamples?"texelFetch(cacheId"+(t+3)+", texel, 0) "+i+"); ":"vec4(0) "+i+"); ")+i,this.#tempGlsl+=`
        for (int i = 0; i < 4; i++) if (id`+t+`[i].xyzw == id.xyzw) {
          color += c`+t+"[i].xyz + ip"+t+`[i].xyz * 256.0;
          counter ++;
        }
        `}this.#tempGlsl+=`
        color /= counter;
      
        if (hdr == 1) {
          // Apply Reinhard tone mapping
          color = color / (color + vec3(1));
          // Gamma correction
          // float gamma = 0.8;
          // color = pow(4.0 * color, vec3(1.0 / gamma)) / 4.0 * 1.3;
        }

        renderColor = vec4(color, 1.0);
      }`,this.#textureList=[],this.#pbrList=[],this.#translucencyList=[];var e=Math.floor(.25*(Math.min(this.#gl.getParameter(this.#gl.MAX_VERTEX_UNIFORM_VECTORS),this.#gl.getParameter(this.#gl.MAX_FRAGMENT_UNIFORM_VECTORS))-16)),t=(console.log("MAX_TRANSFORMS evaluated to",e),GLLib.addCompileTimeConstant(pathtracer_vertex_default,"MAX_TRANSFORMS",e)),e=GLLib.addCompileTimeConstant(pathtracer_fragment_default,"MAX_TRANSFORMS",e),t=(a=GLLib.compile(this.#gl,t,e),n=GLLib.compile(this.#gl,GLLib.postVertex,this.#tempGlsl),this.#gl.bindVertexArray(b),this.#engineState.pathtracingUniformLocations=PathtracingUniformLocationIdentifiers.map(e=>this.#gl.getUniformLocation(a,e)),this.#gl.getUniformBlockIndex(a,"transformMatrix")),e=this.#gl.getActiveUniformBlockParameter(a,t,this.#gl.UNIFORM_BLOCK_DATA_SIZE),t=(l=this.#gl.createBuffer(),this.#gl.bindBuffer(this.#gl.UNIFORM_BUFFER,l),this.#gl.bufferData(this.#gl.UNIFORM_BUFFER,e,this.#gl.DYNAMIC_DRAW),this.#gl.bindBuffer(this.#gl.UNIFORM_BUFFER,null),this.#gl.bindBufferBase(this.#gl.UNIFORM_BUFFER,0,l),c=this.#gl.getUniformIndices(a,["rotation","shift"]),u=this.#gl.getActiveUniforms(a,c,this.#gl.UNIFORM_OFFSET),this.#gl.getUniformBlockIndex(a,"transformMatrix"));if(this.#gl.uniformBlockBinding(a,t,0),this.#gl.disable(this.#gl.BLEND),this.#gl.enable(this.#gl.DEPTH_TEST),this.#gl.depthMask(!0),this.#gl.enable(this.#gl.CULL_FACE),this.#gl.clearColor(0,0,0,0),this.#gl.useProgram(a),this.#pbrAtlas=this.#gl.createTexture(),this.#translucencyAtlas=this.#gl.createTexture(),this.#textureAtlas=this.#gl.createTexture(),this.#lightTexture=this.#gl.createTexture(),this.#geometryTexture=this.#gl.createTexture(),this.#sceneTexture=this.#gl.createTexture(),[o,s]=[this.#gl.createBuffer(),this.#gl.createBuffer()],this.#gl.bindBuffer(this.#gl.ARRAY_BUFFER,o),this.#gl.enableVertexAttribArray(0),this.#gl.vertexAttribIPointer(0,1,this.#gl.INT,!1,0,0),this.#gl.vertexAttribDivisor(0,1),this.#gl.bindBuffer(this.#gl.ARRAY_BUFFER,s),this.#gl.enableVertexAttribArray(1),this.#gl.vertexAttribIPointer(1,1,this.#gl.INT,!1,0,0),this.config.temporal){g=new Array(this.config.temporalSamples),p=new Array(this.config.temporalSamples),v=new Array(this.config.temporalSamples);for(let e=0;e<this.config.temporalSamples;e++)g[e]=this.#gl.createTexture(),p[e]=this.#gl.createTexture(),v[e]=this.#gl.createTexture();[h]=[this.#gl.createFramebuffer()],this.#gl.bindVertexArray(T),this.#gl.useProgram(n),r=this.#gl.getUniformLocation(n,"hdr"),_=new Array(this.config.temporalSamples),x=new Array(this.config.temporalSamples),y=new Array(this.config.temporalSamples);for(let e=0;e<this.config.temporalSamples;e++)_[e]=this.#gl.getUniformLocation(n,"cache"+e),x[e]=this.#gl.getUniformLocation(n,"cacheIp"+e),y[e]=this.#gl.getUniformLocation(n,"cacheId"+e);e=this.#gl.createBuffer();this.#gl.bindBuffer(this.#gl.ARRAY_BUFFER,e),this.#gl.enableVertexAttribArray(0),this.#gl.vertexAttribPointer(0,2,this.#gl.FLOAT,!1,0,0),this.#gl.bindBuffer(this.#gl.ARRAY_BUFFER,e),this.#gl.bufferData(this.#gl.ARRAY_BUFFER,Float32Array.from([0,0,1,0,0,1,1,1,0,1,1,0]),this.#gl.DYNAMIC_DRAW),f=this.#gl.createFramebuffer()}G(),this.updateScene(),w(),this.#resizeEvent=window.addEventListener("resize",()=>w()),requestAnimationFrame(()=>A())},G=()=>{var e=[t,i,d];this.config.temporal&&e.push(...g,...p,...v),e.forEach(e=>{this.#gl.bindTexture(this.#gl.TEXTURE_2D,e),this.#gl.texImage2D(this.#gl.TEXTURE_2D,0,this.#gl.RGBA,this.#gl.canvas.width,this.#gl.canvas.height,0,this.#gl.RGBA,this.#gl.UNSIGNED_BYTE,null),GLLib.setTexParams(this.#gl)}),this.#gl.bindTexture(this.#gl.TEXTURE_2D,m),this.#gl.texImage2D(this.#gl.TEXTURE_2D,0,this.#gl.DEPTH_COMPONENT24,this.#gl.canvas.width,this.#gl.canvas.height,0,this.#gl.DEPTH_COMPONENT,this.#gl.UNSIGNED_INT,null),GLLib.setTexParams(this.#gl)},w=()=>{this.canvas.width=this.canvas.clientWidth*this.config.renderQuality,this.canvas.height=this.canvas.clientHeight*this.config.renderQuality,this.#gl.viewport(0,0,this.canvas.width,this.canvas.height),G(),this.#AAObject&&this.#AAObject.createTexture()};S()}},Renderer=class{device;scene;textureAtlas;pbrAtlas;translucencyAtlas;textureList=[];pbrList=[];translucencyList=[];textureGroupLayout;textureGroup;lightSourceLength=0;lightBuffer;primaryLightSources;constructor(e){this.scene=e}async generateAtlasView(e){let[i,n]=this.scene.standardTextureSizes,r=Math.floor(2048/i);var t=document.createElement("canvas");let a=t.getContext("2d");0===e.length?(t.width=i,t.height=n,a.imageSmoothingEnabled=!1,a.fillRect(0,0,i,n)):(t.width=Math.min(i*e.length,2048),t.height=n*(Math.floor(i*e.length/2048)+1),console.log(t.width,t.height),a.imageSmoothingEnabled=!1,e.forEach(async(e,t)=>a.drawImage(e,i*(t%r),n*Math.floor(t/r),i,n)));var e=await createImageBitmap(t),o=await this.device.createTexture({format:"rgba8unorm",size:[t.width,t.height],usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});return this.device.queue.copyExternalImageToTexture({source:e,flipY:!0},{texture:o},{width:t.width,height:t.height}),this.lightSourceLength=0,this.lightBuffer=this.device.createBuffer({size:8*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),o.createView()}async updateTextureAtlas(e=!1){!e&&this.scene.textures.length===this.textureList.length&&this.scene.textures.every((e,t)=>e===this.textureList[t])||(this.textureList=this.scene.textures,this.textureAtlas=await this.generateAtlasView(this.scene.textures))}async updatePbrAtlas(e=!1){!e&&this.scene.pbrTextures.length===this.pbrList.length&&this.scene.pbrTextures.every((e,t)=>e===this.pbrList[t])||(this.pbrList=this.scene.pbrTextures,this.pbrAtlas=await this.generateAtlasView(this.scene.pbrTextures))}async updateTranslucencyAtlas(e=!1){!e&&this.scene.translucencyTextures.length===this.translucencyList.length&&this.scene.translucencyTextures.every((e,t)=>e===this.translucencyList[t])||(this.translucencyList=this.scene.translucencyTextures,this.translucencyAtlas=await this.generateAtlasView(this.scene.translucencyTextures))}async updateTextureGroup(){var e=[this.textureAtlas,this.pbrAtlas,this.translucencyAtlas];this.textureGroup=this.device.createBindGroup({label:"texture binding group",layout:this.textureGroupLayout,entries:e.map((e,t)=>({binding:t,resource:e}))})}updatePrimaryLightSources(){var n=[],e=(0===this.scene.primaryLightSources.length?n=[0,0,0,0,0,0,0,0]:this.scene.primaryLightSources.forEach(e=>{var t=Object.is(e.intensity)?this.scene.defaultLightIntensity:e.intensity,i=Object.is(e.variation)?this.scene.defaultLightVariation:e.variation;n.push(e[0],e[1],e[2],0,t,i,0,0)}),new Float32Array(n));this.lightSourceLength!==e.length&&(this.lightSourceLength=e.length,this.lightBuffer=this.device.createBuffer({size:e.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST})),this.device.queue.writeBuffer(this.lightBuffer,0,e)}},fxaa_default2="struct FXAAParams {\n    edge_threshold_min: f32,\n    edge_threshold_max: f32,\n    subpix_quality: f32,\n    _padding: f32\n};\n\n@group(0) @binding(0) var input_texture: texture_2d<f32>;\n@group(0) @binding(1) var output_texture: texture_storage_2d<rgba32float, write>;\n@group(0) @binding(2) var<uniform> params: FXAAParams;\n\n// Helper function to get luminance from RGB\nfn luminance(color: vec3<f32>) -> f32 {\n    return dot(color, vec3<f32>(0.299, 0.587, 0.114));\n}\n\n@compute @workgroup_size(8, 8)\nfn compute(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    // Convert global_id to u32 for comparison with texture size\n    let screen_pos = vec2<u32>(global_id.xy);\n    let texture_size = textureDimensions(input_texture);\n    \n    // Early exit if outside render bounds\n    if (screen_pos.x >= texture_size.x || screen_pos.y >= texture_size.y) {\n        return;\n    }\n\n    // Convert to i32 for texture loading\n    let load_pos = vec2<i32>(screen_pos);\n    let texel_size = vec2<f32>(1.0) / vec2<f32>(texture_size);\n    \n    // Sample the 3x3 neighborhood\n    let center = textureLoad(input_texture, load_pos, 0);\n    let north = textureLoad(input_texture, load_pos + vec2<i32>(0, 1), 0);\n    let south = textureLoad(input_texture, load_pos + vec2<i32>(0, -1), 0);\n    let east = textureLoad(input_texture, load_pos + vec2<i32>(1, 0), 0);\n    let west = textureLoad(input_texture, load_pos + vec2<i32>(-1, 0), 0);\n    \n    // Get luminance values\n    let luma_center = luminance(center.rgb);\n    let luma_north = luminance(north.rgb);\n    let luma_south = luminance(south.rgb);\n    let luma_east = luminance(east.rgb);\n    let luma_west = luminance(west.rgb);\n    \n    // Find min and max luma in 3x3 neighborhood\n    let luma_min = min(luma_center, min(min(luma_north, luma_south), min(luma_east, luma_west)));\n    let luma_max = max(luma_center, max(max(luma_north, luma_south), max(luma_east, luma_west)));\n    \n    // Compute local contrast\n    let luma_range = luma_max - luma_min;\n    \n    // Early exit if contrast is lower than minimum\n    if (luma_range < max(params.edge_threshold_min, luma_max * params.edge_threshold_max)) {\n        textureStore(output_texture, load_pos, center);\n        return;\n    }\n    \n    // Compute horizontal and vertical gradients\n    let horizontal = abs(luma_west + luma_east - 2.0 * luma_center) * 2.0 +\n                    abs(luma_north + luma_south - 2.0 * luma_center);\n    let vertical = abs(luma_north + luma_south - 2.0 * luma_center) * 2.0 +\n                  abs(luma_west + luma_east - 2.0 * luma_center);\n    \n    // Determine edge direction\n    let is_horizontal = horizontal >= vertical;\n    \n    // Choose positive and negative endpoints\n    let gradient_step = select(vec2<f32>(0.0, texel_size.y), vec2<f32>(texel_size.x, 0.0), is_horizontal);\n    let pos_grad = select(luma_north, luma_east, is_horizontal);\n    let neg_grad = select(luma_south, luma_west, is_horizontal);\n    \n    // Compute local gradient\n    let gradient = max(\n        abs(pos_grad - luma_center),\n        abs(neg_grad - luma_center)\n    );\n    \n    // Calculate blend factor\n    let blend_factor = smoothstep(0.0, 1.0, gradient / luma_range);\n    let subpix_blend = clamp(blend_factor * params.subpix_quality, 0.0, 1.0);\n    \n    // Perform anti-aliasing blend\n    var result: vec4<f32>;\n    if (is_horizontal) {\n        let blend_color = mix(west, east, subpix_blend);\n        result = mix(center, blend_color, 0.5);\n    } else {\n        let blend_color = mix(south, north, subpix_blend);\n        result = mix(center, blend_color, 0.5);\n    }\n    \n    textureStore(output_texture, load_pos, result);\n}\n",FXAA2=class{#pipeline;#texture;#device;#canvas;#bindGroupLayout;#bindGroup;#uniformBuffer;constructor(e,t){this.#device=e,this.#canvas=t,this.#bindGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{type:"float",sampleType:"unfilterable-float"}},{binding:1,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:"rgba32float",viewDimension:"2d"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]}),this.#uniformBuffer=e.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.createTexture()}get textureInView(){return this.#texture.createView({dimension:"2d"})}get textureInView2dArray(){return this.#texture.createView({dimension:"2d-array",arrayLayerCount:1})}createTexture=()=>{try{this.#texture.destroy()}catch{}this.#texture=this.#device.createTexture({size:[this.#canvas.width,this.#canvas.height,1],format:"rgba32float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC})};createBindGroup=e=>{this.#bindGroup=this.#device.createBindGroup({layout:this.#bindGroupLayout,entries:[{binding:0,resource:this.#texture.createView()},{binding:1,resource:e.createView()},{binding:2,resource:{buffer:this.#uniformBuffer}}]}),this.#pipeline=this.#device.createComputePipeline({label:"fxaa pipeline",layout:this.#device.createPipelineLayout({bindGroupLayouts:[this.#bindGroupLayout]}),compute:{module:this.#device.createShaderModule({code:fxaa_default2}),entryPoint:"compute"}});e=new Float32Array([1/16,.25,.25]);this.#device.queue.writeBuffer(this.#uniformBuffer,0,e)};renderFrame=e=>{var e=e.beginComputePass(),t=(e.setPipeline(this.#pipeline),e.setBindGroup(0,this.#bindGroup),Math.ceil(this.#canvas.width/8)),i=Math.ceil(this.#canvas.height/8);e.dispatchWorkgroups(t,i),e.end()}},taa_default2="struct Uniforms {\n    frame_index: f32,\n    frames: f32,\n    random_vecs: vec2<f32>\n};\n\n@group(0) @binding(0) var input_texture: texture_2d_array<f32>;\n@group(0) @binding(1) var output_texture: texture_storage_2d<rgba32float, write>;\n@group(0) @binding(2) var<uniform> uniforms: Uniforms;\n\n// Helper function to calculate color variance\nfn calculate_neighborhood_bounds(center_pos: vec2<i32>) -> mat2x3<f32> {\n    var min_color = vec3<f32>(1.0f);\n    var max_color = vec3<f32>(0.0f);\n    var mean_color = vec3<f32>(0.0f);\n    var mean_sq_color = vec3<f32>(0.0f);\n    var sample_count = 0.0f;\n\n    // Sample 3x3 neighborhood with gaussian weights\n    for (var y = -1; y <= 1; y++) {\n        for (var x = -1; x <= 1; x++) {\n            let sample_pos = center_pos + vec2<i32>(x, y);\n            let weight = (1.0f - abs(f32(x)) * 0.5f) * (1.0f - abs(f32(y)) * 0.5f);\n            let sample = textureLoad(input_texture, sample_pos, u32(uniforms.frame_index), 0).xyz;\n            \n            mean_color += sample * weight;\n            mean_sq_color += sample * sample * weight;\n            min_color = min(min_color, sample);\n            max_color = max(max_color, sample);\n            sample_count += weight;\n        }\n    }\n\n    mean_color /= sample_count;\n    mean_sq_color /= sample_count;\n    \n    // Calculate variance and adjust bounds\n    let variance = max(mean_sq_color - mean_color * mean_color, vec3<f32>(0.0));\n    let std_dev = sqrt(variance);\n    \n    // Expand the color bounds based on local variance\n    let gamma = 1.25f;\n    min_color = max(min_color, mean_color - std_dev * gamma);\n    max_color = min(max_color, mean_color + std_dev * gamma);\n    \n    return mat2x3<f32>(min_color, max_color);\n}\n\n@compute @workgroup_size(8, 8)\nfn compute(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    let screen_pos = global_id.xy;\n    let texture_size = textureDimensions(input_texture);\n    \n    if (screen_pos.x >= texture_size.x || screen_pos.y >= texture_size.y) {\n        return;\n    }\n\n    let center_pos = vec2<i32>(screen_pos);\n    let current_color = textureLoad(input_texture, center_pos, u32(uniforms.frame_index), 0).xyz;\n    \n    // Calculate color bounds\n    let bounds = calculate_neighborhood_bounds(center_pos);\n    let min_color = bounds[0];\n    let max_color = bounds[1];\n\n    // Accumulate history samples with improved clamping\n    var final_color = current_color;\n    var weight_sum = 1.0f;\n    \n    for (var i = 0; i < i32(uniforms.frames); i++) {\n        if (i == i32(uniforms.frame_index)) {\n            continue;\n        }\n        \n        let history_color = textureLoad(input_texture, center_pos, u32(i), 0).xyz;\n        \n        // Clamp history color to neighborhood bounds\n        let clamped_color = clamp(history_color, min_color, max_color);\n        \n        // Calculate confidence weight based on how much clamping was needed\n        let clamp_amount = length(history_color - clamped_color);\n        let confidence = 1.0f - smoothstep(0.0f, 0.1f, clamp_amount);\n        \n        final_color += clamped_color * confidence;\n        weight_sum += confidence;\n    }\n\n    final_color /= weight_sum;\n    textureStore(output_texture, screen_pos, vec4<f32>(final_color, 1.0f));\n}",FRAMES2=4,TAA2=class{#pipeline;#texture;#device;#canvas;frameIndex=0;#randomVecs;#bindGroupLayout;#bindGroup;#uniformBuffer;constructor(e,t){this.#device=e,this.#canvas=t,this.#randomVecs=this.genPseudoRandomVecsWith0Sum(FRAMES2),this.#bindGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{type:"rgba32float",sampleType:"unfilterable-float",viewDimension:"2d-array"}},{binding:1,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:"rgba32float",viewDimension:"2d"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]}),this.#pipeline=e.createComputePipeline({label:"taa pipeline",layout:e.createPipelineLayout({bindGroupLayouts:[this.#bindGroupLayout]}),compute:{module:e.createShaderModule({code:taa_default2}),entryPoint:"compute"}}),this.#uniformBuffer=e.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.createTexture()}get textureInView(){return this.#texture.createView({dimension:"2d",baseArrayLayer:this.frameIndex,arrayLayerCount:1})}get textureInView2dArray(){return this.#texture.createView({dimension:"2d-array",baseArrayLayer:this.frameIndex,arrayLayerCount:1})}createTexture=()=>{this.#texture=this.#device.createTexture({size:[this.#canvas.width,this.#canvas.height,FRAMES2],format:"rgba32float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC})};createBindGroup=e=>{this.#bindGroup=this.#device.createBindGroup({layout:this.#bindGroupLayout,entries:[{binding:0,resource:this.#texture.createView({dimension:"2d-array",arrayLayerCount:FRAMES2})},{binding:1,resource:e.createView()},{binding:2,resource:{buffer:this.#uniformBuffer}}]})};renderFrame=async e=>{this.frameIndex=(this.frameIndex+1)%FRAMES2;var t=new Float32Array([this.frameIndex,FRAMES2,this.#randomVecs[this.frameIndex][0],this.#randomVecs[this.frameIndex][1]]),t=(this.#device.queue.writeBuffer(this.#uniformBuffer,0,t),e.beginComputePass()),e=(t.setPipeline(this.#pipeline),t.setBindGroup(0,this.#bindGroup),Math.ceil(this.#canvas.width/8)),i=Math.ceil(this.#canvas.height/8);t.dispatchWorkgroups(e,i),t.end()};jitter=()=>{var e=(this.frameIndex+1)%FRAMES2,t=.3/Math.min(this.#canvas.width,this.#canvas.height);return{x:this.#randomVecs[e][0]*t,y:this.#randomVecs[e][1]*t}};genPseudoRandomVecsWith0Sum=i=>{var n=new Array(i).fill(0).map(()=>new Array(2)),r=(n[0]=[0,1],n[1]=[1,0],[1,1]);for(let t=2;t<i;t++)for(let e=0;e<2;e++){var a=Math.max(-Math.min(t+1,i-1-t),r[e]-1),o=Math.min(Math.min(t+1,i-1-t),r[e]+1);n[t][e]=.5*(o+a+(o-a)*Math.sign(Math.random()-.5)*(.5*Math.random())**.5)-r[e],r[e]+=n[t][e]}return n}},pathtracer_depth_default="const PI: f32 = 3.141592653589793;\nconst PHI: f32 = 1.61803398874989484820459;\nconst SQRT3: f32 = 1.7320508075688772;\nconst POW32: f32 = 4294967296.0;\nconst POW23M1: f32 = 8388607.0;\nconst POW23M1U: u32 = 8388607u;\nconst BIAS: f32 = 0.0000152587890625;\nconst INV_PI: f32 = 0.3183098861837907;\nconst INV_255: f32 = 0.00392156862745098;\n\nstruct Transform {\n    rotation: mat3x3<f32>,\n    shift: vec3<f32>,\n};\n\nstruct Uniforms {\n    view_matrix: mat3x3<f32>,\n    view_matrix_jitter: mat3x3<f32>,\n\n    camera_position: vec3<f32>,\n    ambient: vec3<f32>,\n\n    texture_size: vec2<f32>,\n    render_size: vec2<f32>,\n\n    samples: f32,\n    max_reflections: f32,\n    min_importancy: f32,\n    use_filter: f32,\n\n    tonemapping_operator: f32,\n    is_temporal: f32,\n    temporal_target: f32\n};\n\nstruct VertexOut {\n    @builtin(position) pos: vec4<f32>,\n    @location(0) absolute_position: vec3<f32>,\n    @location(1) uv: vec2<f32>,\n    @location(2) clip_space: vec3<f32>,\n    @location(3) @interpolate(flat) triangle_id: i32,\n};\n\n@group(0) @binding(0) var<storage, read_write> depth_buffer: array<atomic<u32>>;\n\n@group(1) @binding(0) var<storage, read> indices: array<i32>;\n@group(1) @binding(1) var<storage, read> geometry: array<f32>;\n\n@group(2) @binding(0) var<uniform> uniforms: Uniforms;\n@group(2) @binding(1) var<storage, read> transforms: array<Transform>;\n\n\nconst base_uvs: array<vec2<f32>, 3> = array(\n    vec2<f32>(1.0f, 0.0f),\n    vec2<f32>(0.0f, 1.0f),\n    vec2<f32>(0.0f, 0.0f)\n);\n\n@vertex\nfn vertex(\n    @builtin(vertex_index) vertex_index: u32,\n    @builtin(instance_index) instance_index: u32\n) -> VertexOut {\n    var out: VertexOut;\n\n    let vertex_num: i32 = i32(vertex_index) % 3;\n    out.triangle_id = indices[instance_index];\n    let geometry_index: i32 = out.triangle_id * 12;\n    let v_i: i32 = geometry_index + vertex_num * 3;\n    // Transform position\n    let relative_position: vec3<f32> = vec3<f32>(geometry[v_i], geometry[v_i + 1], geometry[v_i + 2]);\n    // Get transformation ID\n    let t_i: i32 = i32(geometry[geometry_index + 9]) << 1u;\n    // Trasform position\n    let transform: Transform = transforms[t_i];\n    out.absolute_position = (transform.rotation * relative_position) + transform.shift;\n    // Set uv to vertex uv and let the vertex interpolation generate the values in between\n    switch (vertex_num) {\n        case 0: {\n            out.uv = vec2<f32>(1.0f, 0.0f);\n        }\n        case 1: {\n            out.uv = vec2<f32>(0.0f, 1.0f);\n        }\n        case 2, default {\n            out.uv = vec2<f32>(0.0f, 0.0f);\n        }\n    }\n    out.clip_space = uniforms.view_matrix_jitter * (out.absolute_position - uniforms.camera_position);\n    // Set triangle position in clip space\n    out.pos = vec4<f32>(out.clip_space.xy, 0.0, out.clip_space.z);\n    return out;\n}\n\n// FRAGMENT SHADER ------------------------------------------------------------------------------------------------------------------------\n\n@fragment\nfn fragment(\n    @location(0) absolute_position: vec3<f32>,\n    @location(1) uv: vec2<f32>,\n    @location(2) clip_space: vec3<f32>,\n    @location(3) @interpolate(flat) triangle_id: i32\n) -> @location(0) vec4<f32> {\n\n    // Get canvas size\n    let screen_space: vec2<f32> = (clip_space.xy / clip_space.z) * 0.5 + 0.5;\n    let coord: vec2<u32> = vec2<u32>(\n        u32(uniforms.render_size.x * screen_space.x),\n        u32(uniforms.render_size.y  * (1.0 - screen_space.y))\n    );\n\n    let buffer_index: u32 = coord.x + u32(uniforms.render_size.x) * coord.y;\n    // Only save if texel is closer to camera then previously\n    let current_depth: u32 = POW23M1U - u32(POW23M1 / (1.0f + exp(- clip_space.z * INV_255)));\n    // Store in texture\n    atomicMax(&depth_buffer[buffer_index], current_depth);\n    return vec4<f32>(1.0f);\n}",pathtracer_raster_default="const PI: f32 = 3.141592653589793;\nconst PHI: f32 = 1.61803398874989484820459;\nconst SQRT3: f32 = 1.7320508075688772;\nconst POW32: f32 = 4294967296.0;\nconst POW32U: u32 = 4294967295u;\nconst POW23M1: f32 = 8388607.0;\nconst POW23M1U: u32 = 8388607u;\nconst BIAS: f32 = 0.0000152587890625;\nconst INV_PI: f32 = 0.3183098861837907;\nconst INV_255: f32 = 0.00392156862745098;\n\nstruct Transform {\n    rotation: mat3x3<f32>,\n    shift: vec3<f32>,\n};\n\nstruct Uniforms {\n    view_matrix: mat3x3<f32>,\n    view_matrix_jitter: mat3x3<f32>,\n\n    camera_position: vec3<f32>,\n    ambient: vec3<f32>,\n\n    texture_size: vec2<f32>,\n    render_size: vec2<f32>,\n\n    samples: f32,\n    max_reflections: f32,\n    min_importancy: f32,\n    use_filter: f32,\n\n    tonemapping_operator: f32,\n    is_temporal: f32,\n    temporal_target: f32\n};\n\nstruct VertexOut {\n    @builtin(position) pos: vec4<f32>,\n    @location(0) absolute_position: vec3<f32>,\n    @location(1) uv: vec2<f32>,\n    @location(2) clip_space: vec3<f32>,\n    @location(3) @interpolate(flat) triangle_id: i32,\n};\n\n\n@group(0) @binding(0) var<storage, read> depth_buffer: array<u32>;\n@group(0) @binding(1) var <storage, read_write> triangle_id_buffer: array<i32>;\n@group(0) @binding(2) var texture_absolute_position: texture_storage_2d<rgba32float, write>;\n@group(0) @binding(3) var texture_uv: texture_storage_2d<rg32float, write>;\n\n@group(1) @binding(0) var<storage, read> indices: array<i32>;\n@group(1) @binding(1) var<storage, read> geometry: array<f32>;\n\n@group(2) @binding(0) var<uniform> uniforms: Uniforms;\n@group(2) @binding(1) var<storage, read> transforms: array<Transform>;\n\n\n\n@vertex\nfn vertex(\n    @builtin(vertex_index) vertex_index : u32,\n    @builtin(instance_index) instance_index: u32\n) -> VertexOut {\n    var out: VertexOut;\n\n    let vertex_num: i32 = i32(vertex_index) % 3;\n    out.triangle_id = indices[instance_index];\n    let geometry_index: i32 = out.triangle_id * 12;\n    let v_i: i32 = geometry_index + vertex_num * 3;\n    // Transform position\n    let relative_position: vec3<f32> = vec3<f32>(geometry[v_i], geometry[v_i + 1], geometry[v_i + 2]);\n    // Get transformation ID\n    let t_i: i32 = i32(geometry[geometry_index + 9]) << 1u;\n    // Trasform position\n    let transform: Transform = transforms[t_i];\n    out.absolute_position = (transform.rotation * relative_position) + transform.shift;\n    // Set uv to vertex uv and let the vertex interpolation generate the values in between\n    switch (vertex_num) {\n        case 0: {\n            out.uv = vec2<f32>(1.0f, 0.0f);\n        }\n        case 1: {\n            out.uv = vec2<f32>(0.0f, 1.0f);\n        }\n        case 2, default {\n            out.uv = vec2<f32>(0.0f, 0.0f);\n        }\n    }\n    out.clip_space = uniforms.view_matrix_jitter * (out.absolute_position - uniforms.camera_position);\n    // Set triangle position in clip space\n    out.pos = vec4<f32>(out.clip_space.xy, 0.0f, out.clip_space.z);\n    return out;\n}\n\n// FRAGMENT SHADER ------------------------------------------------------------------------------------------------------------------------\n\n@fragment\nfn fragment(\n    @location(0) absolute_position: vec3<f32>,\n    @location(1) uv: vec2<f32>,\n    @location(2) clip_space: vec3<f32>,\n    @location(3) @interpolate(flat) triangle_id: i32\n) -> @location(0) vec4<f32> {\n\n    // Get canvas size\n    let screen_space: vec2<f32> = (clip_space.xy / clip_space.z) * 0.5f + 0.5f;\n    let coord: vec2<u32> = vec2<u32>(\n        u32(uniforms.render_size.x * screen_space.x),\n        u32(uniforms.render_size.y  * (1.0f - screen_space.y))\n    );\n\n    let buffer_index: u32 = coord.x + u32(uniforms.render_size.x) * coord.y;\n    // Only save if texel is closer to camera then previously\n    // let current_depth: u32 = u32(POW23M1 / (1.0f + exp(- clip_space.z * INV_255)));\n    let current_depth: u32 = POW23M1U - u32(POW23M1 / (1.0f + exp(- clip_space.z * INV_255)));\n\n    if (current_depth == depth_buffer[buffer_index]) {\n        // Save values for compute pass\n        textureStore(texture_absolute_position, coord, vec4<f32>(absolute_position, 0.0f));\n        textureStore(texture_uv, coord, vec4<f32>(uv, 0.0f, 0.0f));\n        triangle_id_buffer[buffer_index] = triangle_id;\n    }\n\n    return vec4<f32>(f32(triangle_id % 3) / 3.0f, f32(triangle_id % 2) / 2.0f, f32(triangle_id % 5) / 5.0f, 1.0f);\n}",pathtracer_shift_default="const POW32U: u32 = 4294967295u;\nconst POW23M1: f32 = 8388607.0;\nconst INV_255: f32 = 1.0f / 255.0f;\n\nstruct Uniforms {\n    view_matrix: mat3x3<f32>,\n    view_matrix_jitter: mat3x3<f32>,\n\n    camera_position: vec3<f32>,\n    ambient: vec3<f32>,\n\n    texture_size: vec2<f32>,\n    render_size: vec2<f32>,\n\n    samples: f32,\n    max_reflections: f32,\n    min_importancy: f32,\n    use_filter: f32,\n\n    tonemapping_operator: f32,\n    is_temporal: f32,\n    temporal_count: f32,\n    temporal_max: f32\n};\n\n@group(0) @binding(0) var accumulated: texture_2d_array<f32>;\n@group(0) @binding(1) var shift_out: texture_storage_2d_array<rgba32float, write>;\n@group(0) @binding(2) var<storage, read_write> shift_lock: array<atomic<u32>>;\n\n@group(1) @binding(0) var<uniform> uniforms: Uniforms;\n\n@compute\n@workgroup_size(8, 8)\nfn compute(\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_id) local_invocation_id : vec3<u32>,\n    @builtin(global_invocation_id) global_invocation_id : vec3<u32>,\n    @builtin(local_invocation_index) local_invocation_index: u32,\n    @builtin(num_workgroups) num_workgroups: vec3<u32>\n) {\n    // Get texel position of screen\n    let screen_pos: vec2<u32> = global_invocation_id.xy;\n    \n    if (screen_pos.x > u32(uniforms.render_size.x) || screen_pos.y > u32(uniforms.render_size.y)) {\n        return;\n    }\n    \n    // Extract color value from old position\n    let fine_color_acc: vec4<f32> = textureLoad(accumulated, screen_pos, 0, 0);\n    let coarse_color_acc: vec4<f32> = textureLoad(accumulated, screen_pos, 1, 0);\n    let fine_color_low_variance_acc: vec4<f32> = textureLoad(accumulated, screen_pos, 2, 0);\n    let coarse_color_low_variance_acc: vec4<f32> = textureLoad(accumulated, screen_pos, 3, 0);\n    // Extract 3d position value\n    let position_old: vec4<f32> = textureLoad(accumulated, screen_pos, 4, 0);\n    \n    // Map postion according to current camera positon and view matrix to clip space\n    let relative_position: vec3<f32> = position_old.xyz - uniforms.camera_position;\n    let clip_space: vec3<f32> = uniforms.view_matrix * relative_position;\n    // Project onto screen and shift origin to the corner\n    let screen_space: vec2<f32> = (clip_space.xy / clip_space.z) * 0.5 + 0.5;\n    // Translate to texel value\n    let coord: vec2<u32> = vec2<u32>(\n        u32((uniforms.render_size.x * screen_space.x)),\n        u32((uniforms.render_size.y * (1.0f - screen_space.y)))\n    );\n\n    let last_frame = position_old.w == uniforms.temporal_count;\n    // Skip if data is not from last frame\n    if (!last_frame) {\n        return;\n    }\n\n    let buffer_index: u32 = coord.x + u32(uniforms.render_size.x) * coord.y;\n    // Attempt to acquire lock.\n    let lock: u32 = atomicOr(&shift_lock[buffer_index], 1u);\n    if (lock == 1u) {\n        // If lock is already set then another thread is already working on this pixel\n        return;\n    }\n    \n    // Write to shift buffer\n    textureStore(shift_out, coord, 0, fine_color_acc);\n    textureStore(shift_out, coord, 1, coarse_color_acc);\n    textureStore(shift_out, coord, 2, fine_color_low_variance_acc);\n    textureStore(shift_out, coord, 3, coarse_color_low_variance_acc);\n    textureStore(shift_out, coord, 4, position_old);\n\n\n    // Release lock.\n    atomicStore(&shift_lock[buffer_index], 0u);\n}",pathtracer_compute_default="const PI: f32 = 3.141592653589793;\nconst PHI: f32 = 1.61803398874989484820459;\nconst SQRT3: f32 = 1.7320508075688772;\nconst POW32: f32 = 4294967296.0;\nconst POW32U: u32 = 4294967295u;\nconst BIAS: f32 = 0.0000152587890625;\nconst INV_PI: f32 = 0.3183098861837907;\nconst INV_255: f32 = 0.00392156862745098;\nconst INV_65535: f32 = 0.000015259021896696422;\n\nstruct Transform {\n    rotation: mat3x3<f32>,\n    shift: vec3<f32>,\n};\n\nstruct Light {\n    position: vec3<f32>,\n    strength_variation: vec2<f32>,\n}\n\nstruct Uniforms {\n    view_matrix: mat3x3<f32>,\n    view_matrix_jitter: mat3x3<f32>,\n\n    camera_position: vec3<f32>,\n    ambient: vec3<f32>,\n\n    texture_size: vec2<f32>,\n    render_size: vec2<f32>,\n\n    samples: f32,\n    max_reflections: f32,\n    min_importancy: f32,\n    use_filter: f32,\n\n    tonemapping_operator: f32,\n    is_temporal: f32,\n    temporal_target: f32\n};\n\n@group(0) @binding(0) var compute_out: texture_storage_2d_array<rgba32float, write>;\n@group(0) @binding(1) var<storage, read> triangle_id_buffer: array<i32>;\n@group(0) @binding(2) var texture_absolute_position: texture_2d<f32>;\n@group(0) @binding(3) var texture_uv: texture_2d<f32>;\n\n@group(1) @binding(0) var texture_atlas: texture_2d<f32>;\n@group(1) @binding(1) var pbr_atlas: texture_2d<f32>;\n@group(1) @binding(2) var translucency_atlas: texture_2d<f32>;\n\n@group(2) @binding(0) var<storage, read> indices: array<i32>;\n@group(2) @binding(1) var<storage, read> geometry: array<f32>;\n@group(2) @binding(2) var<storage, read> scene: array<f32>;\n\n@group(3) @binding(0) var<uniform> uniforms: Uniforms;\n@group(3) @binding(1) var<storage, read> transforms: array<Transform>;\n@group(3) @binding(2) var<storage, read> lights: array<Light>;\n\nstruct Ray {\n    origin: vec3<f32>,\n    unit_direction: vec3<f32>,\n};\n\nstruct Material {\n    albedo: vec3<f32>,\n    rme: vec3<f32>,\n    tpo: vec3<f32>\n};\n\nstruct Hit {\n    suv: vec3<f32>,\n    triangle_id: i32\n};\n\nstruct Sample {\n    color: vec3<f32>,\n    render_id_w: f32\n}\n\n// var render_id: vec4<f32> = vec4<f32>(0.0f);\n// var render_original_id: vec4<f32> = vec4<f32>(0.0f);\n\n// Lookup values for texture atlases\nfn fetchTexVal(atlas: texture_2d<f32>, uv: vec2<f32>, tex_num: f32, default_val: vec3<f32>) -> vec3<f32> {\n    // Return default value if no texture is set\n    if (tex_num == - 1.0f) {\n        return default_val;\n    }\n    // Get dimensions of texture atlas\n    let atlas_size: vec2<f32> = vec2<f32>(textureDimensions(atlas));\n    let width: f32 = tex_num * uniforms.texture_size.x;\n    let offset: vec2<f32> = vec2<f32>(\n        width % atlas_size.x,\n        atlas_size.y - floor(width / atlas_size.x) * uniforms.texture_size.y\n    );\n    // WebGPU quirk of having upsidedown height for textures\n    let atlas_texel: vec2<i32> = vec2<i32>(offset + uv * uniforms.texture_size * vec2<f32>(1.0f, -1.0f));\n    // Fetch texel on requested coordinate\n    let tex_val: vec3<f32> = textureLoad(atlas, atlas_texel, 0).xyz;\n    return tex_val;\n}\n\nfn noise(n: vec2<f32>, seed: f32) -> vec4<f32> {\n    // let temp_component: vec2<f32> = fract(vec2<f32>(uniforms.temporal_target * PHI, cos(uniforms.temporal_target) + PHI));\n    // return fract(sin(dot(n.xy, vec2<f32>(12.9898f, 78.233f)) + vec4<f32>(53.0f, 59.0f, 61.0f, 67.0f) * seed) * 43758.5453f) * 2.0f - 1.0f;\n    return fract(sin(dot(n.xy, vec2<f32>(12.9898f, 78.233f)) + vec4<f32>(53.0f, 59.0f, 61.0f, 67.0f) * sin(seed + uniforms.temporal_target * PHI)) * 43758.5453f) * 2.0f - 1.0f;\n\n}\n\nfn moellerTrumbore(t: mat3x3<f32>, ray: Ray, l: f32) -> vec3<f32> {\n    let edge1: vec3<f32> = t[1] - t[0];\n    let edge2: vec3<f32> = t[2] - t[0];\n    let pvec: vec3<f32> = cross(ray.unit_direction, edge2);\n    let det: f32 = dot(edge1, pvec);\n    if(abs(det) < BIAS) {\n        return vec3<f32>(0.0f);\n    }\n    let inv_det: f32 = 1.0f / det;\n    let tvec: vec3<f32> = ray.origin - t[0];\n    let u: f32 = dot(tvec, pvec) * inv_det;\n    if(u < BIAS || u > 1.0f) {\n        return vec3<f32>(0.0f);\n    }\n    let qvec: vec3<f32> = cross(tvec, edge1);\n    let v: f32 = dot(ray.unit_direction, qvec) * inv_det;\n    let uv_sum: f32 = u + v;\n    if(v < BIAS || uv_sum > 1.0f) {\n        return vec3<f32>(0.0f);\n    }\n    let s: f32 = dot(edge2, qvec) * inv_det;\n    if(s > l || s <= BIAS) {\n        return vec3<f32>(0.0f);\n    }\n    return vec3<f32>(s, u, v);\n}\n\n// Simplified Moeller-Trumbore algorithm for detecting only forward facing triangles\nfn moellerTrumboreCull(t: mat3x3<f32>, ray: Ray, l: f32) -> bool {\n    let edge1 = t[1] - t[0];\n    let edge2 = t[2] - t[0];\n    let pvec = cross(ray.unit_direction, edge2);\n    let det = dot(edge1, pvec);\n    let inv_det = 1.0f / det;\n    if(det < BIAS) { \n        return false;\n    }\n    let tvec = ray.origin - t[0];\n    let u: f32 = dot(tvec, pvec) * inv_det;\n    if(u < BIAS || u > 1.0f) {\n        return false;\n    }\n    let qvec: vec3<f32> = cross(tvec, edge1);\n    let v: f32 = dot(ray.unit_direction, qvec) * inv_det;\n    if(v < BIAS || u + v > 1.0f) {\n        return false;\n    }\n    let s: f32 = dot(edge2, qvec) * inv_det;\n    return (s <= l && s > BIAS);\n}\n\n// Don't return intersection point, because we're looking for a specific triangle\nfn rayCuboid(min_corner: vec3<f32>, max_corner: vec3<f32>, ray: Ray, l: f32) -> bool {\n    let v0: vec3<f32> = (min_corner - ray.origin) / ray.unit_direction;\n    let v1: vec3<f32> = (max_corner - ray.origin) / ray.unit_direction;\n    let tmin: f32 = max(max(min(v0.x, v1.x), min(v0.y, v1.y)), min(v0.z, v1.z));\n    let tmax: f32 = min(min(max(v0.x, v1.x), max(v0.y, v1.y)), max(v0.z, v1.z));\n    return tmax >= max(tmin, BIAS) && tmin < l;\n}\n\n// Test for closest ray triangle intersection\n// return intersection position in world space and index of target triangle in geometryTex\n// plus triangle and transformation Id\nfn rayTracer(ray: Ray) -> Hit {\n    // Cache transformed ray attributes\n    var t_ray: Ray = Ray(ray.origin, ray.unit_direction);\n    // Inverse of transformed normalized ray\n    var cached_t_i: i32 = 0;\n    // Latest intersection which is now closest to origin\n    var hit: Hit = Hit(vec3(0.0f), - 1);\n    // Precomput max length\n    var min_len: f32 = POW32;\n    // Get texture size as max iteration value\n    let size: i32 = i32(arrayLength(&geometry)) / 12;\n    // Iterate through lines of texture\n    for (var i: i32 = 0; i < size; i++) {\n        // Get position of current triangle/vertex in geometryTex\n        let index: i32 = i * 12;\n        // Fetch triangle coordinates from scene graph\n        let a = vec3<f32>(geometry[index    ], geometry[index + 1], geometry[index + 2]);\n        let b = vec3<f32>(geometry[index + 3], geometry[index + 4], geometry[index + 5]);\n        let c = vec3<f32>(geometry[index + 6], geometry[index + 7], geometry[index + 8]);\n\n        let t_i: i32 = i32(geometry[index + 9]) << 1u;\n        // Test if cached transformed variables are still valid\n        if (t_i != cached_t_i) {\n            let i_i: i32 = t_i + 1;\n            cached_t_i = t_i;\n            let i_transform = transforms[i_i];\n            t_ray = Ray(\n                i_transform.rotation * (ray.origin + i_transform.shift),\n                i_transform.rotation * ray.unit_direction\n            );\n        }\n        // Three cases:\n        // indicator = 0        => end of list: stop loop\n        // indicator = 1        => is bounding volume: do AABB intersection test\n        // indicator = 2        => is triangle: do triangle intersection test\n        switch i32(geometry[index + 10]) {\n            case 0 {\n                return hit;\n            }\n            case 1: {\n                if(!rayCuboid(a, b, t_ray, min_len)) {\n                    i += i32(c.x);\n                }\n            }\n            case 2: {\n                let triangle: mat3x3<f32> = mat3x3<f32>(a, b, c);\n                 // Test if triangle intersects ray\n                let intersection: vec3<f32> = moellerTrumbore(triangle, t_ray, min_len);\n                // Test if ray even intersects\n                if(intersection.x != 0.0) {\n                    // Calculate intersection point\n                    hit = Hit(intersection, i);\n                    // Update maximum object distance for future rays\n                    min_len = intersection.x;\n                }\n            }\n            default: {\n                continue;\n            }\n        }\n    }\n    // Tested all triangles, but there is no intersection\n    return hit;\n}\n\n// Simplified rayTracer to only test if ray intersects anything\nfn shadowTest(ray: Ray, l: f32) -> bool {\n    // Cache transformed ray attributes\n    var t_ray: Ray = Ray(ray.origin, ray.unit_direction);\n    // Inverse of transformed normalized ray\n    var cached_t_i: i32 = 0;\n    // Precomput max length\n    let min_len: f32 = l;\n    // Get texture size as max iteration value\n    let size: i32 = i32(arrayLength(&geometry)) / 12;\n    // Iterate through lines of texture\n    for (var i: i32 = 0; i < size; i++) {\n        // Get position of current triangle/vertex in geometryTex\n        let index: i32 = i * 12;\n        // Fetch triangle coordinates from scene graph\n        let a = vec3<f32>(geometry[index    ], geometry[index + 1], geometry[index + 2]);\n        let b = vec3<f32>(geometry[index + 3], geometry[index + 4], geometry[index + 5]);\n        let c = vec3<f32>(geometry[index + 6], geometry[index + 7], geometry[index + 8]);\n\n        let t_i: i32 = i32(geometry[index + 9]) << 1u;\n        // Test if cached transformed variables are still valid\n        if (t_i != cached_t_i) {\n            let i_i: i32 = t_i + 1;\n            cached_t_i = t_i;\n            let i_transform = transforms[i_i];\n            t_ray = Ray(\n                i_transform.rotation * (ray.origin + i_transform.shift),\n                normalize(i_transform.rotation * ray.unit_direction)\n            );\n        }\n        // Three cases:\n        // indicator = 0        => end of list: stop loop\n        // indicator = 1        => is bounding volume: do AABB intersection test\n        // indicator = 2        => is triangle: do triangle intersection test\n        switch i32(geometry[index + 10]) {\n            case 0 {\n                return false;\n            }\n            case 1: {\n                if(!rayCuboid(a, b, t_ray, min_len)) {\n                    i += i32(c.x);\n                }\n            }\n            case 2: {\n                let triangle: mat3x3<f32> = mat3x3<f32>(a, b, c);\n                // Test for triangle intersection in positive light ray direction\n                if(moellerTrumboreCull(triangle, t_ray, min_len)) {\n                    return true;\n                }\n            }\n            default: {\n                continue;\n            }\n        }\n    }\n    // Tested all triangles, but there is no intersection\n    return false;\n}\n\nfn trowbridgeReitz(alpha: f32, n_dot_h: f32) -> f32 {\n    let numerator: f32 = alpha * alpha;\n    let denom: f32 = n_dot_h * n_dot_h * (numerator - 1.0f) + 1.0f;\n    return numerator / max(PI * denom * denom, BIAS);\n}\n\nfn schlickBeckmann(alpha: f32, n_dot_x: f32) -> f32 {\n    let k: f32 = alpha * 0.5f;\n    let denom: f32 = max(n_dot_x * (1.0f - k) + k, BIAS);\n    return n_dot_x / denom;\n}\n\nfn smith(alpha: f32, n_dot_v: f32, n_dot_l: f32) -> f32 {\n    return schlickBeckmann(alpha, n_dot_v) * schlickBeckmann(alpha, n_dot_l);\n}\n\nfn fresnel(f0: vec3<f32>, theta: f32) -> vec3<f32> {\n    // Use Schlick approximation\n    return f0 + (1.0f - f0) * pow(1.0f - theta, 5.0f);\n}\n\n\nfn forwardTrace(material: Material, light_dir: vec3<f32>, strength: f32, n: vec3<f32>, v: vec3<f32>) -> vec3<f32> {\n    let len_p1: f32 = 1.0f + length(light_dir);\n    // Apply inverse square law\n    let brightness: f32 = strength / (len_p1 * len_p1);\n\n    let l: vec3<f32> = normalize(light_dir);\n    let h: vec3<f32> = normalize(v + l);\n\n    let v_dot_h: f32 = max(dot(v, h), 0.0f);\n    let n_dot_l: f32 = max(dot(n, l), 0.0f);\n    let n_dot_h: f32 = max(dot(n, h), 0.0f);\n    let n_dot_v: f32 = max(dot(n, v), 0.0f);\n\n    let alpha: f32 = material.rme.x * material.rme.x;\n    let brdf: f32 = mix(1.0f, n_dot_v, material.rme.y);\n    let f0: vec3<f32> = material.albedo * brdf;\n\n    let ks: vec3<f32> = fresnel(f0, v_dot_h);\n    let kd: vec3<f32> = (1.0f - ks) * (1.0f - material.rme.y);\n    let lambert: vec3<f32> = material.albedo * INV_PI;\n\n    let cook_torrance_numerator: vec3<f32> = ks * trowbridgeReitz(alpha, n_dot_h) * smith(alpha, n_dot_v, n_dot_l);\n    let cook_torrance_denominator: f32 = max(4.0f * n_dot_v * n_dot_l, BIAS);\n\n    let cook_torrance: vec3<f32> = cook_torrance_numerator / cook_torrance_denominator;\n    let radiance: vec3<f32> = kd * lambert + cook_torrance;\n\n    // Outgoing light to camera\n    return radiance * n_dot_l * brightness;\n}\n\nfn reservoirSample(material: Material, ray: Ray, random_vec: vec4<f32>, rough_n: vec3<f32>, smooth_n: vec3<f32>, geometry_offset: f32, dont_filter: bool, i: i32) -> vec3<f32> {\n    var local_color: vec3<f32> = vec3<f32>(0.0f);\n    var reservoir_length: f32 = 0.0f;\n    var total_weight: f32 = 0.0f;\n    var reservoir_num: i32 = 0;\n    var reservoir_weight: f32 = 0.0f;\n    var reservoir_light_pos: vec3<f32>;\n    var reservoir_light_dir: vec3<f32>;\n    var last_random: vec2<f32> = noise(random_vec.zw, BIAS).xy;\n\n    let size: i32 = i32(arrayLength(&lights));\n    for (var j: i32 = 0; j < size; j++) {\n        // Read light from storage buffer\n        var light: Light = lights[j];\n        // Skip if strength is negative or zero\n        if (light.strength_variation.x <= 0.0f) {\n            continue;\n        }\n        // Increment light weight\n        reservoir_length += 1.0f;\n        // Alter light source position according to variation.\n        light.position += random_vec.xyz * light.strength_variation.y;\n        let dir: vec3<f32> = light.position - ray.origin;\n\n        let color_for_light: vec3<f32> = forwardTrace(material, dir, light.strength_variation.x, rough_n, - ray.unit_direction);\n\n        local_color += color_for_light;\n        let weight: f32 = length(color_for_light);\n\n        total_weight += weight;\n        if (abs(last_random.y) * total_weight <= weight) {\n            reservoir_num = j;\n            reservoir_weight = weight;\n            reservoir_light_pos = light.position;\n            reservoir_light_dir = dir;\n        }\n        // Update pseudo random variable.\n        last_random = noise(last_random, BIAS).zw;\n    }\n\n    let unit_light_dir: vec3<f32> = normalize(reservoir_light_dir);\n    // Compute quick exit criterion to potentially skip expensive shadow test\n    let show_color: bool = reservoir_length == 0.0f || reservoir_weight == 0.0f;\n    let show_shadow: bool = dot(smooth_n, unit_light_dir) <= BIAS;\n    // Apply emissive texture and ambient light\n    let base_luminance: vec3<f32> = vec3<f32>(material.rme.z) * material.albedo;\n    // Test if in shadow\n    if (show_color) {\n        return local_color + base_luminance;\n    }\n\n    if (show_shadow) {\n        return base_luminance;\n    }\n    // Apply geometry offset\n    let offset_target: vec3<f32> = ray.origin + geometry_offset * smooth_n;\n    let light_ray: Ray = Ray(offset_target, unit_light_dir);\n\n    if (shadowTest(light_ray, length(reservoir_light_dir))) {\n        return base_luminance;\n    } else {\n        return local_color + base_luminance;\n    }\n}\n\nfn lightTrace(init_hit: Hit, origin: vec3<f32>, camera: vec3<f32>, clip_space: vec2<f32>, cos_sample_n: f32, bounces: i32) -> vec3<f32> {\n    // Set bool to false when filter becomes necessary\n    var dont_filter: bool = true;\n    // Use additive color mixing technique, so start with black\n    var final_color: vec3<f32> = vec3<f32>(0.0f);\n    var importancy_factor: vec3<f32> = vec3(1.0f);\n    // originalColor = vec3(1.0f);\n    var hit: Hit = init_hit;\n    var ray: Ray = Ray(camera, normalize(origin - camera));\n    var last_hit_point: vec3<f32> = camera;\n    // Iterate over each bounce and modify color accordingly\n    for (var i: i32 = 0; i < bounces && length(importancy_factor/* * originalColor*/) >= uniforms.min_importancy * SQRT3; i++) {\n        let index_g: i32 = hit.triangle_id * 12;\n        // Fetch triangle coordinates from scene graph texture\n        let relative_t: mat3x3<f32> = mat3x3<f32>(\n            geometry[index_g    ], geometry[index_g + 1], geometry[index_g + 2],\n            geometry[index_g + 3], geometry[index_g + 4], geometry[index_g + 5],\n            geometry[index_g + 6], geometry[index_g + 7], geometry[index_g + 8]\n        );\n\n        let transform: Transform = transforms[i32(geometry[index_g + 9]) << 1];\n        // Transform triangle\n        let t: mat3x3<f32> = transform.rotation * relative_t;\n        // Transform hit point\n        ray.origin = hit.suv.x * ray.unit_direction + ray.origin;\n        let offset_ray_target: vec3<f32> = ray.origin - transform.shift;\n\n        let geometry_n: vec3<f32> = normalize(cross(t[0] - t[1], t[0] - t[2]));\n        let diffs: vec3<f32> = vec3<f32>(\n            distance(offset_ray_target, t[0]),\n            distance(offset_ray_target, t[1]),\n            distance(offset_ray_target, t[2])\n        );\n        // Fetch scene texture data\n        let index_s: i32 = hit.triangle_id * 28;\n        // Pull normals\n        let normals: mat3x3<f32> = transform.rotation * mat3x3<f32>(\n            scene[index_s    ], scene[index_s + 1], scene[index_s + 2],\n            scene[index_s + 3], scene[index_s + 4], scene[index_s + 5],\n            scene[index_s + 6], scene[index_s + 7], scene[index_s + 8]\n        );\n        // Calculate barycentric coordinates\n        let uvw: vec3<f32> = vec3(1.0 - hit.suv.y - hit.suv.z, hit.suv.y, hit.suv.z);\n        // Interpolate smooth normal\n        var smooth_n: vec3<f32> = normalize(normals * uvw);\n        // to prevent unnatural hard shadow / reflection borders due to the difference between the smooth normal and geometry\n        let angles: vec3<f32> = acos(abs(geometry_n * normals));\n        let angle_tan: vec3<f32> = clamp(tan(angles), vec3<f32>(0.0f), vec3<f32>(1.0f));\n        let geometry_offset: f32 = dot(diffs * angle_tan, uvw);\n        // Interpolate final barycentric texture coordinates between UV's of the respective vertices\n        let barycentric: vec2<f32> = mat3x2<f32>(\n            scene[index_s + 9 ], scene[index_s + 10], scene[index_s + 11],\n            scene[index_s + 12], scene[index_s + 13], scene[index_s + 14]\n        ) * uvw;\n        // Gather material attributes (albedo, roughness, metallicity, emissiveness, translucency, partical density and optical density aka. IOR) out of world texture\n        let tex_num: vec3<f32>          = vec3<f32>(scene[index_s + 15], scene[index_s + 16], scene[index_s + 17]);\n\n        let albedo_default: vec3<f32>   = vec3<f32>(scene[index_s + 18], scene[index_s + 19], scene[index_s + 20]);\n        let rme_default: vec3<f32>      = vec3<f32>(scene[index_s + 21], scene[index_s + 22], scene[index_s + 23]);\n        let tpo_default: vec3<f32>      = vec3<f32>(scene[index_s + 24], scene[index_s + 25], scene[index_s + 26]);\n\n        let material: Material = Material (\n            fetchTexVal(texture_atlas, barycentric, tex_num.x, albedo_default),\n            fetchTexVal(pbr_atlas, barycentric, tex_num.y, rme_default),\n            fetchTexVal(translucency_atlas, barycentric, tex_num.z, tpo_default),\n        );\n        \n        ray = Ray(ray.origin, normalize(ray.origin - last_hit_point));\n        // If ray reflects from inside or onto an transparent object,\n        // the surface faces in the opposite direction as usual\n        var sign_dir: f32 = sign(dot(ray.unit_direction, smooth_n));\n        smooth_n *= - sign_dir;\n\n        // Generate pseudo random vector\n        let fi: f32 = f32(i);\n        let random_vec: vec4<f32> = noise(clip_space.xy * length(ray.origin - last_hit_point), fi + cos_sample_n * PHI);\n        let random_spheare_vec: vec3<f32> = normalize(smooth_n + normalize(random_vec.xyz));\n        let brdf: f32 = mix(1.0f, abs(dot(smooth_n, ray.unit_direction)), material.rme.y);\n\n        // Alter normal according to roughness value\n        let roughness_brdf: f32 = material.rme.x * brdf;\n        let rough_n: vec3<f32> = normalize(mix(smooth_n, random_spheare_vec, roughness_brdf));\n\n        let h: vec3<f32> = normalize(rough_n - ray.unit_direction);\n        let v_dot_h = max(dot(- ray.unit_direction, h), 0.0f);\n        let f0: vec3<f32> = material.albedo * brdf;\n        let f: vec3<f32> = fresnel(f0, v_dot_h);\n\n        let fresnel_reflect: f32 = max(f.x, max(f.y, f.z));\n        // object is solid or translucent by chance because of the fresnel effect\n        let is_solid: bool = material.tpo.x * fresnel_reflect <= abs(random_vec.w);\n        // Test if filter is already necessary\n        // if (i == 1) firstRayLength = min(length(ray.origin - lastHitPoint) / length(lastHitPoint - camera), firstRayLength);\n        // Determine local color considering PBR attributes and lighting\n        let local_color: vec3<f32> = reservoirSample(material, ray, random_vec, - sign_dir * rough_n, - sign_dir * smooth_n, geometry_offset, dont_filter, i);\n        // Calculate primary light sources for this pass if ray hits non translucent object\n        final_color += local_color * importancy_factor;\n\n        // Multiply albedo with either absorption value or filter color\n        /*\n        if (dont_filter) {\n            // Update last used tpo.x value\n            // originalTPOx = material.tpo.x;\n            originalColor *= material.albedo;\n            // Add filtering intensity for respective surface\n            // originalRMEx += material.rme.x;\n            // Update render id\n            vec4 renderIdUpdate = pow(2.0f, - fi) * vec4(combineNormalRME(smoothNormal, material.rme), 0.0f);\n\n            renderId += renderIdUpdate;\n            if (i == 0) renderOriginalId += renderIdUpdate;\n            // Update dontFilter variable\n            dont_filter = (material.rme.x < 0.01f && isSolid) || !isSolid;\n\n            if(is_solid && material.tpo.x != 0.0f) {\n                // glassFilter += 1.0f;\n                dont_filter = false;\n            }\n        }\n        */\n        importancy_factor = importancy_factor * material.albedo;\n        // forwardTrace(material: Material, light_dir: vec3<f32>, strength: f32, n: vec3<f32>, v: vec3<f32>)\n        // importancy_factor = importancy_factor * forwardTrace(material, - old_ray_unit_dir, 4.0f, smooth_n, ray.unit_direction);\n        // Handle translucency and skip rest of light calculation\n        if(is_solid) {\n            // Calculate reflecting ray\n            ray.unit_direction = normalize(mix(reflect(ray.unit_direction, smooth_n), random_spheare_vec, roughness_brdf));\n        } else {\n            let eta: f32 = mix(1.0f / material.tpo.z, material.tpo.z, max(sign_dir, 0.0f));\n            // Refract ray depending on IOR (material.tpo.z)\n            ray.unit_direction = normalize(mix(refract(ray.unit_direction, smooth_n, eta), random_spheare_vec, roughness_brdf));\n        }\n        // Calculate next intersection\n        hit = rayTracer(ray);\n        // Stop loop if there is no intersection and ray goes in the void\n        if (hit.triangle_id == - 1) {\n            break;\n            // return final_color + importancy_factor * uniforms.ambient;\n        }\n        // Update other parameters\n        last_hit_point = ray.origin;\n    }\n    // Return final pixel color\n    return final_color + importancy_factor * uniforms.ambient;\n}\n\n@compute\n@workgroup_size(8, 8)\nfn compute(\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_id) local_invocation_id : vec3<u32>,\n    @builtin(global_invocation_id) global_invocation_id : vec3<u32>,\n    @builtin(local_invocation_index) local_invocation_index: u32,\n    @builtin(num_workgroups) num_workgroups: vec3<u32>\n) {\n    // Get texel position of screen\n    let screen_pos: vec2<u32> = global_invocation_id.xy;//local_invocation_id.xy + (workgroup_id.xy * 16u);\n    let buffer_index: u32 = global_invocation_id.x + u32(uniforms.render_size.x) * global_invocation_id.y;\n    // Get based clip space coordinates (with 0.0 at upper left corner)\n    // Load attributes from fragment shader out ofad(texture_triangle_id, screen_pos).x;\n    let triangle_id: i32 = triangle_id_buffer[buffer_index];\n\n    if (triangle_id == 0) {\n        // If there is no triangle render ambient color \n        textureStore(compute_out, screen_pos, 0, vec4<f32>(uniforms.ambient, 1.0f));\n        // And overwrite position with 0 0 0 0\n        if (uniforms.is_temporal == 1.0f) {\n            // Amount of temporal passes\n            // let depth: u32 = textureNumLayers(compute_out) / 2;\n            // Store position in target\n            textureStore(compute_out, screen_pos, 1, vec4<f32>(0.0f));\n        }\n        return;\n    }\n\n    let absolute_position: vec3<f32> = textureLoad(texture_absolute_position, screen_pos, 0).xyz;\n    let uv: vec2<f32> = textureLoad(texture_uv, screen_pos, 0).xy;\n\n    let clip_space: vec2<f32> = vec2<f32>(screen_pos) / vec2<f32>(num_workgroups.xy * 8u);\n    \n    let uvw: vec3<f32> = vec3<f32>(uv, 1.0f - uv.x - uv.y);\n    // Generate hit struct for pathtracer\n    let init_hit: Hit = Hit(vec3<f32>(distance(absolute_position, uniforms.camera_position), uvw.yz), triangle_id);\n\n    var final_color = vec3<f32>(0.0f);\n    // Generate multiple samples\n    for(var i: i32 = 0; i < i32(uniforms.samples); i++) {\n        // Use cosine as noise in random coordinate picker\n        let cos_sample_n = cos(f32(i));\n        final_color += lightTrace(init_hit, absolute_position, uniforms.camera_position, clip_space, cos_sample_n, i32(uniforms.max_reflections));\n    }\n    // Average ray colors over samples.\n    let inv_samples: f32 = 1.0f / uniforms.samples;\n    final_color *= inv_samples;\n\n    // Write to additional textures for temporal pass\n    if (uniforms.is_temporal == 1.0f) {\n        // Render to compute target\n        textureStore(compute_out, screen_pos, 0, vec4<f32>(final_color, 1.0f));\n        // Store position in target\n        textureStore(compute_out, screen_pos, 1, vec4<f32>(absolute_position, 1.0f));\n    } else {\n        // Render to compute target\n        textureStore(compute_out, screen_pos, 0, vec4<f32>(final_color, 1.0f));\n    }\n}",pathtracer_selective_average_default="const PI: f32 = 3.141592653589793;\nconst POW32U: u32 = 4294967295u;\nconst SQRT3: f32 = 1.7320508075688772;\nconst BIAS: f32 = 0.0000152587890625;\nconst INV_1023: f32 = 0.0009775171065493646;\n\n/*\nconst YUV_MATRIX: mat3x3<f32> = mat3x3<f32>(\n    0.299,      0.587,     0.114,\n  - 0.14713,  - 0.28886,   0.436,\n    0.615,    - 0.51499, - 0.10001\n);\n*/\n\nstruct Uniforms {\n    view_matrix: mat3x3<f32>,\n    view_matrix_jitter: mat3x3<f32>,\n\n    camera_position: vec3<f32>,\n    ambient: vec3<f32>,\n\n    texture_size: vec2<f32>,\n    render_size: vec2<f32>,\n\n    samples: f32,\n    max_reflections: f32,\n    min_importancy: f32,\n    use_filter: f32,\n\n    tonemapping_operator: f32,\n    is_temporal: f32,\n    temporal_count: f32,\n    temporal_max: f32\n};\n\n@group(0) @binding(0) var compute_out: texture_2d_array<f32>;\n@group(0) @binding(1) var shift_out: texture_2d_array<f32>;\n@group(0) @binding(2) var accumulated: texture_storage_2d_array<rgba32float, write>;\n\n@group(1) @binding(0) var<uniform> uniforms: Uniforms;\n\n@compute\n@workgroup_size(8, 8)\nfn compute(\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_id) local_invocation_id : vec3<u32>,\n    @builtin(global_invocation_id) global_invocation_id : vec3<u32>,\n    @builtin(local_invocation_index) local_invocation_index: u32,\n    @builtin(num_workgroups) num_workgroups: vec3<u32>\n) {\n    // Get texel position of screen\n    let screen_pos: vec2<u32> = global_invocation_id.xy;\n    if (screen_pos.x > u32(uniforms.render_size.x) || screen_pos.y > u32(uniforms.render_size.y)) {\n        return;\n    }\n\n    // Get current color and position.\n    let color_cur: vec4<f32> = textureLoad(compute_out, screen_pos, 0, 0);\n    let position_cur: vec4<f32> = textureLoad(compute_out, screen_pos, 1, 0);\n\n    // Map postion according to current camera positon and view matrix to clip space\n    let clip_space: vec3<f32> = uniforms.view_matrix * (position_cur.xyz - uniforms.camera_position);\n    // Project onto screen and shift origin to the corner\n    let screen_space: vec2<f32> = (clip_space.xy / clip_space.z) * 0.5 + 0.5;\n    // Translate to texel value\n    var coord: vec2<u32> = vec2<u32>(\n        u32((uniforms.render_size.x * screen_space.x)),\n        u32((uniforms.render_size.y * (1.0f - screen_space.y)))\n    );\n\n    // Extract 3d position value\n    let fine_color_acc: vec4<f32> = textureLoad(shift_out, coord, 0, 0);\n    let coarse_color_acc: vec4<f32> = textureLoad(shift_out, coord, 1, 0);\n    let fine_color_low_variance_acc: vec4<f32> = textureLoad(shift_out, coord, 2, 0);\n    let coarse_color_low_variance_acc: vec4<f32> = textureLoad(shift_out, coord, 3, 0);\n    let position_old: vec4<f32> = textureLoad(shift_out, coord, 4, 0);\n    \n    // If absolute position is all zeros then there is nothing to do\n    let dist: f32 = distance(position_cur.xyz, position_old.xyz);\n    let cur_depth: f32 = distance(position_cur.xyz, uniforms.camera_position.xyz);\n    // let norm_color_diff = dot(normalize(current_color.xyz), normalize(accumulated_color.xyz));\n\n    let croped_cur_color: vec3<f32> = min(color_cur.xyz, vec3<f32>(1.0f));\n\n    var fine_color: vec4<f32> = color_cur;\n    var fine_color_low_variance: vec3<f32> = croped_cur_color;\n    var fine_count: f32 = 0.0f;\n\n    var coarse_color: vec4<f32> = color_cur;\n    var coarse_color_low_variance: vec3<f32> = croped_cur_color;\n    var coarse_count: f32 = 0.0f;\n\n    let is_pos = position_cur.x != 0.0f || position_cur.y != 0.0f || position_cur.z != 0.0f || position_cur.w != 0.0f;\n\n    \n    let last_frame = position_old.w == uniforms.temporal_count;\n    \n    if (\n        dist <= cur_depth * 8.0f / uniforms.render_size.x\n        && last_frame \n        && is_pos \n    ) {\n        // Add color to total and increase counter by one\n        fine_count = min(fine_color_low_variance_acc.w + 1.0f, 32.0f);\n        fine_color = mix(fine_color_acc, color_cur, 1.0f / fine_count);\n        fine_color_low_variance = mix(fine_color_low_variance_acc.xyz, croped_cur_color, 1.0f / fine_count);\n        coarse_count = min(coarse_color_low_variance_acc.w + 1.0f, 4.0f);\n        coarse_color = mix(coarse_color_acc, color_cur, 1.0f / coarse_count);\n        coarse_color_low_variance = mix(coarse_color_low_variance_acc.xyz, croped_cur_color, 1.0f / coarse_count);\n\n\n        let low_variance_color_length: f32 = (length(fine_color_low_variance) + length(coarse_color_low_variance)) * 0.5f;\n\n        // If the color is not stable enough, use the coarse color\n        if (\n            dot(normalize(fine_color_low_variance + BIAS), normalize(coarse_color_low_variance + BIAS)) < cos(PI * 0.125)\n            || abs(length(fine_color_low_variance) - length(coarse_color_low_variance)) > low_variance_color_length\n        ) {\n            // If the color is not stable enough, use the coarse color\n            fine_color = coarse_color;\n            fine_color_low_variance = coarse_color_low_variance;\n            fine_count = coarse_count;\n        }\n        \n        \n    }\n\n    // Write to accumulated buffer\n    textureStore(accumulated, coord, 0, fine_color);\n    textureStore(accumulated, coord, 1, coarse_color);\n    textureStore(accumulated, coord, 2, vec4<f32>(fine_color_low_variance, fine_count));\n    textureStore(accumulated, coord, 3, vec4<f32>(coarse_color_low_variance, coarse_count));\n    textureStore(accumulated, coord, 4, vec4<f32>(position_cur.xyz, (uniforms.temporal_count + 1.0f) % uniforms.temporal_max));\n}",pathtracer_reproject_default="const POW32U: u32 = 4294967295u;\nconst POW24F: f32 = 16777216.0f;\nconst SQRT2: f32 = 1.4142135623730951f;\n\nstruct Uniforms {\n    view_matrix: mat3x3<f32>,\n    view_matrix_jitter: mat3x3<f32>,\n\n    camera_position: vec3<f32>,\n    ambient: vec3<f32>,\n\n    texture_size: vec2<f32>,\n    render_size: vec2<f32>,\n\n    samples: f32,\n    max_reflections: f32,\n    min_importancy: f32,\n    use_filter: f32,\n\n    tonemapping_operator: f32,\n    is_temporal: f32,\n    temporal_count: f32,\n    temporal_max: f32\n};\n\n@group(0) @binding(0) var accumulated: texture_2d_array<f32>;\n@group(0) @binding(1) var canvas_in: texture_storage_2d<rgba32float, write>;\n// @group(0) @binding(1) var<storage, read_write> buffer_out: array<atomic<u32>>;\n\n@group(1) @binding(0) var<uniform> uniforms: Uniforms;\n\n// atomicStore(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T)\n\n/*\n\nfn store_atomic(pos: vec2<u32>, val: vec4<f32>) {\n    let b_pos: u32 = (pos.x + u32(uniforms.render_size.x) * pos.y) * 4u;\n    // Spread out the float values over the range of u32.\n    let u32vals: vec4<u32> = vec4<u32>(val * POW24F);\n    // Store the u32 values.\n    atomicStore(&buffer_out[b_pos], u32vals.x);\n    atomicStore(&buffer_out[b_pos + 1], u32vals.y);\n    atomicStore(&buffer_out[b_pos + 2], u32vals.z);\n    atomicStore(&buffer_out[b_pos + 3], u32vals.w);\n}\n\nfn add_atomic(pos: vec2<u32>, val: vec4<f32>) {\n    let b_pos: u32 = (pos.x + u32(uniforms.render_size.x) * pos.y) * 4u;\n    // Spread out the float values over the range of u32.\n    let u32vals: vec4<u32> = vec4<u32>(val * POW24F);\n    // Store the u32 values.\n    atomicAdd(&buffer_out[b_pos], u32vals.x);\n    atomicAdd(&buffer_out[b_pos + 1], u32vals.y);\n    atomicAdd(&buffer_out[b_pos + 2], u32vals.z);\n    atomicAdd(&buffer_out[b_pos + 3], u32vals.w);\n}\n\nfn interpolate_store(pos: vec2<f32>, val: vec4<f32>) {\n    let pos_fract: vec2<f32> = fract(pos);\n    let pos_u32: vec2<u32> = vec2<u32>(pos);\n\n    let offsets = mat4x2<f32>(\n        vec2<f32>(0.0f, 0.0f),\n        vec2<f32>(1.0f, 0.0f),\n        vec2<f32>(0.0f, 1.0f),\n        vec2<f32>(1.0f, 1.0f)\n    );\n\n    let distances: vec4<f32> = max(1.0f - vec4<f32>(\n        length(offsets[0] - pos_fract),\n        length(offsets[1] - pos_fract),\n        length(offsets[2] - pos_fract),\n        length(offsets[3] - pos_fract)\n    ), vec4<f32>(0.0f));\n\n    let weights: vec4<f32> = distances / (distances.x + distances.y + distances.z + distances.w);\n\n    // let positions: mat4x2<u32> = pos_u32 + mat4x2<u32>(offsets);\n\n    add_atomic(pos_u32 + vec2<u32>(offsets[0]), val * weights.x);\n    add_atomic(pos_u32 + vec2<u32>(offsets[1]), val * weights.y);\n    add_atomic(pos_u32 + vec2<u32>(offsets[2]), val * weights.z);\n    add_atomic(pos_u32 + vec2<u32>(offsets[3]), val * weights.w);\n}\n*/\n\n@compute\n@workgroup_size(8, 8)\nfn compute(\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_id) local_invocation_id : vec3<u32>,\n    @builtin(global_invocation_id) global_invocation_id : vec3<u32>,\n    @builtin(local_invocation_index) local_invocation_index: u32,\n    @builtin(num_workgroups) num_workgroups: vec3<u32>\n) {\n    // Skip if texel is out of bounds\n    if (global_invocation_id.x > u32(uniforms.render_size.x) || global_invocation_id.y > u32(uniforms.render_size.y)) {\n        return;\n    }\n    \n    // Get texel position of screen\n    let screen_pos: vec2<u32> = global_invocation_id.xy;\n    // Extract color value from old position\n    var color: vec4<f32> = textureLoad(accumulated, screen_pos, 0, 0);\n    // Extract 3d position value\n    let position_cur: vec4<f32> = textureLoad(accumulated, screen_pos, 4, 0);\n    // If data is not from last frame write ambient color\n    if (position_cur.w != (uniforms.temporal_count + 1.0f) % uniforms.temporal_max) {\n        textureStore(canvas_in, screen_pos, vec4<f32>(uniforms.ambient, 1.0f));\n        return;\n    }\n\n    if (uniforms.is_temporal == 1.0f) {\n        // Reproject position to jitter if temporal is enabled\n        let clip_space: vec3<f32> = uniforms.view_matrix_jitter * (position_cur.xyz - uniforms.camera_position);\n        let screen_space: vec2<f32> = (clip_space.xy / clip_space.z) * 0.5 + 0.5;\n\n        let canvas_pos: vec2<u32> = vec2<u32>(\n            u32(uniforms.render_size.x * screen_space.x),\n            u32(uniforms.render_size.y * (1.0f - screen_space.y))\n        );\n\n        textureStore(canvas_in, canvas_pos, color);\n    } else {\n        // Write straight to canvas.\n        textureStore(canvas_in, screen_pos, color);\n    }\n}",canvas_default="const POW32U: u32 = 4294967295u;\n\nstruct Uniforms {\n    view_matrix: mat3x3<f32>,\n    inv_view_matrix: mat3x3<f32>,\n\n    camera_position: vec3<f32>,\n    ambient: vec3<f32>,\n\n    texture_size: vec2<f32>,\n    render_size: vec2<f32>,\n\n    samples: f32,\n    max_reflections: f32,\n    min_importancy: f32,\n    use_filter: f32,\n\n    tonemapping_operator: f32,\n    is_temporal: f32,\n    temporal_target: f32\n};\n\n@group(0) @binding(0) var compute_out: texture_2d<f32>;\n@group(0) @binding(1) var canvas_out: texture_storage_2d<rgba8unorm, write>;\n\n@group(1) @binding(0) var<uniform> uniforms: Uniforms;\n\n@compute\n@workgroup_size(8, 8)\nfn compute(\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_id) local_invocation_id : vec3<u32>,\n    @builtin(global_invocation_id) global_invocation_id : vec3<u32>,\n    @builtin(local_invocation_index) local_invocation_index: u32,\n    @builtin(num_workgroups) num_workgroups: vec3<u32>\n) {\n    // Get texel position of screen\n    let screen_pos: vec2<u32> = global_invocation_id.xy;\n    if (screen_pos.x > u32(uniforms.render_size.x) || screen_pos.y > u32(uniforms.render_size.y)) {\n        return;\n    }\n\n    let buffer_index: u32 = global_invocation_id.x + num_workgroups.x * 8u * global_invocation_id.y;\n\n    let compute_texel: vec4<f32> = textureLoad(compute_out, screen_pos, 0);\n    var compute_color: vec3<f32> = compute_texel.xyz;\n\n    if (uniforms.tonemapping_operator == 1.0f) {\n        // Apply Reinhard tone mapping\n        compute_color = compute_color / (compute_color + vec3<f32>(1.0f));\n        // Gamma correction\n        // let gamma: f32 = 0.8f;\n        // compute_color = pow(4.0f * compute_color, vec3<f32>(1.0f / gamma)) / 4.0f * 1.3f;\n    }\n\n    // Write final color to canvas\n    textureStore(canvas_out, screen_pos, vec4<f32>(compute_color, compute_texel.w));\n}",rasterRenderFormats=["rgba32float","rg32float"],POW32U=2**32-1,TEMPORAL_MAX=8388607,PathTracerWGPU=class extends Renderer{type="pathtracer";config;fps=0;fpsLimit=1/0;#canvas;#context;#adapter;device;#preferedCanvasFormat;#depthPipeline;#rasterPipeline;#computePipeline;#shiftPipeline;#temporalPipeline;#reprojectPipeline;#canvasPipeline;#renderPassDescriptor;#staticBuffers;#dynamicBuffers;#uniformBuffer;#transformBuffer;#depthBuffer;#triangleIdBuffer;#rasterRenderTextures=[];#temporalIn;#shiftTarget;#accumulatedTarget;#shiftLock;#canvasIn;#depthGroupLayout;#rasterRenderGroupLayout;#computeRenderGroupLayout;#rasterDynamicGroupLayout;#computeDynamicGroupLayout;#rasterStaticGroupLayout;#computeStaticGroupLayout;#postDynamicGroupLayout;#shiftGroupLayout;#temporalGroupLayout;#reprojectGroupLayout;#canvasGroupLayout;#depthGroup;#rasterRenderGroup;#computeRenderGroup;#rasterDynamicGroup;#computeDynamicGroup;#rasterStaticGroup;#computeStaticGroup;#postDynamicGroup;#shiftGroup;#temporalGroup;#canvasGroup;#reprojectGroup;#engineState={};#resizeEvent;#halt=!0;#antialiasing;#AAObject;constructor(e,t,i,n){super(t),this.#canvas=e,this.camera=i,this.config=n,navigator.gpu}halt=()=>{this.#halt=!0,window.removeEventListener("resize",this.#resizeEvent)};resize(){let t=Math.round(this.#canvas.clientWidth*this.config.renderQuality),i=Math.round(this.#canvas.clientHeight*this.config.renderQuality);this.#canvas.width=t,this.#canvas.height=i;var e=[this.#canvasIn,...this.#rasterRenderTextures];this.config.temporal&&e.push(this.#shiftTarget,this.#temporalIn),e.forEach(e=>{try{e.destroy()}catch{}}),this.#depthBuffer=this.device.createBuffer({size:i*t*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.#triangleIdBuffer=this.device.createBuffer({size:i*t*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.#rasterRenderTextures=rasterRenderFormats.map(e=>this.device.createTexture({size:[t,i],format:e,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING})),this.#canvasIn=this.device.createTexture({size:[t,i],format:"rgba32float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING}),this.config.temporal&&(this.#temporalIn=this.device.createTexture({size:[t,i,this.config.temporal?2:1],format:"rgba32float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING}),this.#shiftTarget=this.device.createTexture({size:[t,i,5],format:"rgba32float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING}),this.#accumulatedTarget=this.device.createTexture({size:[t,i,5],format:"rgba32float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING}),this.#shiftLock=this.device.createBuffer({size:t*i*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.device.queue.writeBuffer(this.#shiftLock,0,new Uint32Array(new Array(t*i).fill(POW32U)))),this.#AAObject&&this.#AAObject.createTexture()}get canvas(){return this.#canvas}updateScene(i=this.device){var e;i&&(e=this.scene.generateArraysFromGraph(),this.#engineState.bufferLength=e.bufferLength,this.#staticBuffers=[e.idBuffer,e.geometryBuffer,e.sceneBuffer].map(e=>{var t=i.createBuffer({size:e.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});return i.queue.writeBuffer(t,0,e),t}),e=this.#staticBuffers.map((e,t)=>({binding:t,resource:{buffer:e}})),this.#rasterStaticGroup=i.createBindGroup({label:"static binding group for raster pass",layout:this.#rasterStaticGroupLayout,entries:e.slice(0,2)}),this.#computeStaticGroup=i.createBindGroup({label:"static binding group for compute pass",layout:this.#computeStaticGroupLayout,entries:e}))}async render(){this.#halt?(this.#context=this.#canvas.getContext("webgpu"),this.#adapter=await navigator.gpu.requestAdapter(),this.device=await this.#adapter.requestDevice(),this.#preferedCanvasFormat="rgba8unorm",this.#context.configure({device:this.device,format:this.#preferedCanvasFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING}),this.#engineState.intermediateFrames=0,this.#engineState.lastTimeStamp=performance.now(),this.#engineState.temporalFrame=0,await this.updateTextureAtlas(!0),await this.updatePbrAtlas(!0),await this.updateTranslucencyAtlas(!0),this.#prepareEngine(this.device)):console.warn("Renderer already up and running!")}#prepareEngine(e){this.halt(),this.#halt=!1,Object.assign(this.#engineState,{filter:this.config.filter,temporal:this.config.temporal,temporalSamples:this.config.temporalSamples,renderQuality:this.config.renderQuality,bufferLength:0}),this.#depthGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"storage"}}]}),this.#rasterRenderGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.FRAGMENT,storageTexture:{access:"write-only",format:"rgba32float",viewDimension:"2d"}},{binding:3,visibility:GPUShaderStage.FRAGMENT,storageTexture:{access:"write-only",format:"rg32float",viewDimension:"2d"}}]}),this.#computeRenderGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:"rgba32float",viewDimension:"2d-array"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,texture:{type:"float",sampleType:"unfilterable-float"}},{binding:3,visibility:GPUShaderStage.COMPUTE,texture:{type:"float",sampleType:"unfilterable-float"}}]}),this.#rasterStaticGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}}]}),this.#computeStaticGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}]}),this.#rasterDynamicGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}}]}),this.#computeDynamicGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}]}),this.textureGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{type:"uint"}},{binding:1,visibility:GPUShaderStage.COMPUTE,texture:{type:"uint"}},{binding:2,visibility:GPUShaderStage.COMPUTE,texture:{type:"uint"}}]}),this.config.temporal&&(this.#shiftGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{type:"float",sampleType:"unfilterable-float",viewDimension:"2d-array"}},{binding:1,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:"rgba32float",viewDimension:"2d-array"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),this.#temporalGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{type:"float",sampleType:"unfilterable-float",viewDimension:"2d-array"}},{binding:1,visibility:GPUShaderStage.COMPUTE,texture:{type:"float",sampleType:"unfilterable-float",viewDimension:"2d-array"}},{binding:2,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:"rgba32float",viewDimension:"2d-array"}}]}),this.#reprojectGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{type:"float",sampleType:"unfilterable-float",viewDimension:"2d-array"}},{binding:1,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:"rgba32float",viewDimension:"2d"}}]})),this.#postDynamicGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]}),this.#canvasGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{type:"float",sampleType:"unfilterable-float"}},{binding:1,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:"rgba8unorm",viewDimension:"2d"}}]});var t=e.createShaderModule({code:pathtracer_depth_default}),t=(this.#depthPipeline=e.createRenderPipeline({label:"depth pipeline",layout:e.createPipelineLayout({bindGroupLayouts:[this.#depthGroupLayout,this.#rasterStaticGroupLayout,this.#rasterDynamicGroupLayout]}),vertex:{module:t,entryPoint:"vertex"},fragment:{module:t,entryPoint:"fragment",targets:[{format:"rgba8unorm"}]},primitive:{topology:"triangle-list",cullMode:"back"}}),pathtracer_raster_default),t=e.createShaderModule({code:t}),t=(this.#rasterPipeline=e.createRenderPipeline({label:"raster pipeline",layout:e.createPipelineLayout({bindGroupLayouts:[this.#rasterRenderGroupLayout,this.#rasterStaticGroupLayout,this.#rasterDynamicGroupLayout]}),vertex:{module:t,entryPoint:"vertex"},fragment:{module:t,entryPoint:"fragment",targets:[{format:"rgba8unorm"}]},primitive:{topology:"triangle-list",cullMode:"back"}}),pathtracer_compute_default),t=e.createShaderModule({code:t}),t=(this.#computePipeline=e.createComputePipeline({label:"compute pipeline",layout:e.createPipelineLayout({bindGroupLayouts:[this.#computeRenderGroupLayout,this.textureGroupLayout,this.#computeStaticGroupLayout,this.#computeDynamicGroupLayout]}),compute:{module:t,entryPoint:"compute"}}),this.config.temporal&&(t=e.createShaderModule({code:pathtracer_shift_default}),this.#shiftPipeline=e.createComputePipeline({label:"shift pipeline",layout:e.createPipelineLayout({bindGroupLayouts:[this.#shiftGroupLayout,this.#postDynamicGroupLayout]}),compute:{module:t,entryPoint:"compute"}}),t=e.createShaderModule({code:pathtracer_selective_average_default}),this.#temporalPipeline=e.createComputePipeline({label:"selective average pipeline",layout:e.createPipelineLayout({bindGroupLayouts:[this.#temporalGroupLayout,this.#postDynamicGroupLayout]}),compute:{module:t,entryPoint:"compute"}}),t=e.createShaderModule({code:pathtracer_reproject_default}),this.#reprojectPipeline=e.createComputePipeline({label:"reproject pipeline",layout:e.createPipelineLayout({bindGroupLayouts:[this.#reprojectGroupLayout,this.#postDynamicGroupLayout]}),compute:{module:t,entryPoint:"compute"}})),canvas_default),t=e.createShaderModule({code:t});this.#canvasPipeline=e.createComputePipeline({label:"canvas pipeline",layout:e.createPipelineLayout({bindGroupLayouts:[this.#canvasGroupLayout,this.#postDynamicGroupLayout]}),compute:{module:t,entryPoint:"compute"}}),this.#renderPassDescriptor={colorAttachments:[{clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"}]},this.#uniformBuffer=e.createBuffer({size:176,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.updateScene(e),this.resize(),this.#resizeEvent=window.addEventListener("resize",()=>this.resize()),requestAnimationFrame(()=>this.frameCycle(e))}frameCycle(e){if(!this.#halt){var t=performance.now();if(this.#engineState.temporal!==this.config.temporal||this.#engineState.temporalSamples!==this.config.temporalSamples||this.#engineState.renderQuality!==this.config.renderQuality)requestAnimationFrame(()=>this.#prepareEngine(e));else{if(this.updateTextureAtlas(),this.updatePbrAtlas(),this.updateTranslucencyAtlas(),this.updateTextureGroup(),this.updatePrimaryLightSources(),this.#engineState.antialiasing!==this.config.antialiasing){this.#engineState.antialiasing=this.config.antialiasing;var i=this.config.antialiasing.toLowerCase();switch(i){case"fxaa":this.#antialiasing=i,this.#AAObject=new FXAA2(this.device,this.#canvas);break;case"taa":this.#antialiasing=i,this.#AAObject=new TAA2(this.device,this.#canvas);break;default:this.#antialiasing=void 0,this.#AAObject=void 0}}this.renderFrame(),this.#engineState.intermediateFrames++,this.#engineState.temporalFrame=(this.#engineState.temporalFrame+1)%TEMPORAL_MAX;var n=t-this.#engineState.lastTimeStamp;500<n&&(this.fps=(1e3*this.#engineState.intermediateFrames/n).toFixed(0),this.#engineState.lastTimeStamp=t,this.#engineState.intermediateFrames=0),setTimeout(()=>{requestAnimationFrame(()=>this.frameCycle(e))},1e3/this.fpsLimit)}}}async renderFrame(){let e={x:0,y:0};this.#AAObject&&"taa"===this.#antialiasing&&(e=this.#AAObject.jitter());var t={x:this.camera.direction.x,y:this.camera.direction.y},i={x:this.camera.direction.x+e.x,y:this.camera.direction.y+e.y},n=this.#context.getCurrentTexture(),r={binding:0,resource:{buffer:this.#depthBuffer}},a=this.config.temporal||this.#AAObject?!this.config.temporal&&this.#AAObject?this.#AAObject.textureInView2dArray:this.#temporalIn.createView({dimension:"2d-array",arrayLayerCount:2}):this.#canvasIn.createView({dimension:"2d-array",arrayLayerCount:1}),a=(this.#depthGroup=this.device.createBindGroup({label:"depth buffer for depth testing raster pass",layout:this.#depthGroupLayout,entries:[r]}),this.#rasterRenderGroup=this.device.createBindGroup({label:"render output group for raster pass",layout:this.#rasterRenderGroupLayout,entries:[r,{binding:1,resource:{buffer:this.#triangleIdBuffer}},...this.#rasterRenderTextures.map((e,t)=>({binding:t+2,resource:e.createView()}))]}),this.#computeRenderGroup=this.device.createBindGroup({label:"render input group for compute pass",layout:this.#computeRenderGroupLayout,entries:[{binding:0,resource:a},{binding:1,resource:{buffer:this.#triangleIdBuffer}},...this.#rasterRenderTextures.map((e,t)=>({binding:t+2,resource:e.createView()}))]}),this.config.temporal&&(r=this.#AAObject?this.#AAObject.textureInView:this.#canvasIn.createView({dimension:"2d"}),this.#shiftGroup=this.device.createBindGroup({label:"bind group for motion correction pass",layout:this.#shiftGroupLayout,entries:[{binding:0,resource:this.#accumulatedTarget.createView({dimension:"2d-array",arrayLayerCount:5})},{binding:1,resource:this.#shiftTarget.createView({dimension:"2d-array",arrayLayerCount:5})},{binding:2,resource:{buffer:this.#shiftLock}}]}),this.#temporalGroup=this.device.createBindGroup({label:"bind group accumulation pass",layout:this.#temporalGroupLayout,entries:[{binding:0,resource:this.#temporalIn.createView({dimension:"2d-array",arrayLayerCount:2})},{binding:1,resource:this.#shiftTarget.createView({dimension:"2d-array",arrayLayerCount:5})},{binding:2,resource:this.#accumulatedTarget.createView({dimension:"2d-array",arrayLayerCount:5})}]}),this.#reprojectGroup=this.device.createBindGroup({label:"bind group for reprojection pass",layout:this.#reprojectGroupLayout,entries:[{binding:0,resource:this.#accumulatedTarget.createView({dimension:"2d-array",arrayLayerCount:5})},{binding:1,resource:r}]})),this.#AAObject&&this.#AAObject.createBindGroup(this.#canvasIn),this.#canvasGroup=this.device.createBindGroup({label:"render input group for canvas pass",layout:this.#canvasGroupLayout,entries:[{binding:0,resource:this.#canvasIn.createView({dimension:"2d"})},{binding:1,resource:n.createView()}]}),this.#renderPassDescriptor.colorAttachments[0].view=n.createView(),1/this.camera.fov),r=this.#canvas.height*a/this.#canvas.width;let o=[[Math.cos(t.x)*r,0,Math.sin(t.x)*r],[-Math.sin(t.x)*Math.sin(t.y)*a,Math.cos(t.y)*a,Math.cos(t.x)*Math.sin(t.y)*a],[-Math.sin(t.x)*Math.cos(t.y),-Math.sin(t.y),Math.cos(t.x)*Math.cos(t.y)]];var n=[[Math.cos(i.x)*r,0,Math.sin(i.x)*r],[-Math.sin(i.x)*Math.sin(i.y)*a,Math.cos(i.y)*a,Math.cos(i.x)*Math.sin(i.y)*a],[-Math.sin(i.x)*Math.cos(i.y),-Math.sin(i.y),Math.cos(i.x)*Math.cos(i.y)]],t=(this.config.temporal||(o=n),this.config.temporal?this.#engineState.temporalFrame:0),r=(this.device.queue.writeBuffer(this.#uniformBuffer,0,new Float32Array([o[0][0],o[1][0],o[2][0],0,o[0][1],o[1][1],o[2][1],0,o[0][2],o[1][2],o[2][2],0,n[0][0],n[1][0],n[2][0],0,n[0][1],n[1][1],n[2][1],0,n[0][2],n[1][2],n[2][2],0,this.camera.position.x,this.camera.position.y,this.camera.position.z,0,this.scene.ambientLight[0],this.scene.ambientLight[1],this.scene.ambientLight[2],0,this.scene.standardTextureSizes[0],this.scene.standardTextureSizes[1],this.canvas.width,this.canvas.height,this.config.samplesPerRay,this.config.maxReflections,this.config.minImportancy,this.config.filter,this.config.hdr?1:0,this.config.temporal,t,TEMPORAL_MAX])),Transform.buildWGPUArray()),a=(this.#transformBuffer=this.device.createBuffer({size:r.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.device.queue.writeBuffer(this.#transformBuffer,0,r),this.#dynamicBuffers=[this.#uniformBuffer,this.#transformBuffer,this.lightBuffer],this.#dynamicBuffers.map((e,t)=>({binding:t,resource:{buffer:e}}))),i=(this.#rasterDynamicGroup=this.device.createBindGroup({label:"dynamic binding group for raster pass",layout:this.#rasterDynamicGroupLayout,entries:a.slice(0,2)}),this.#computeDynamicGroup=this.device.createBindGroup({label:"dynamic binding group for compute pass",layout:this.#computeDynamicGroupLayout,entries:a}),this.#postDynamicGroup=this.device.createBindGroup({label:"dynamic binding group for post processing passes",layout:this.#postDynamicGroupLayout,entries:a.slice(0,1)}),[Math.ceil(this.canvas.width/8),Math.ceil(this.canvas.height/8)]),n=[Math.ceil(this.canvas.width/8),Math.ceil(this.canvas.height/8)],t=this.device.createCommandEncoder(),r=(t.clearBuffer(this.#depthBuffer),t.clearBuffer(this.#triangleIdBuffer),t.beginRenderPass(this.#renderPassDescriptor)),a=(r.setPipeline(this.#depthPipeline),r.setBindGroup(0,this.#depthGroup),r.setBindGroup(1,this.#rasterStaticGroup),r.setBindGroup(2,this.#rasterDynamicGroup),r.draw(3,this.#engineState.bufferLength),r.end(),t.beginRenderPass(this.#renderPassDescriptor)),r=(a.setPipeline(this.#rasterPipeline),a.setBindGroup(0,this.#rasterRenderGroup),a.setBindGroup(1,this.#rasterStaticGroup),a.setBindGroup(2,this.#rasterDynamicGroup),a.draw(3,this.#engineState.bufferLength),a.end(),t.beginComputePass()),a=(r.setPipeline(this.#computePipeline),r.setBindGroup(0,this.#computeRenderGroup),r.setBindGroup(1,this.textureGroup),r.setBindGroup(2,this.#computeStaticGroup),r.setBindGroup(3,this.#computeDynamicGroup),r.dispatchWorkgroups(n[0],n[1]),r.end(),this.config.temporal&&((a=t.beginComputePass()).setPipeline(this.#shiftPipeline),a.setBindGroup(0,this.#shiftGroup),a.setBindGroup(1,this.#postDynamicGroup),a.dispatchWorkgroups(i[0],i[1]),a.end(),(n=t.beginComputePass()).setPipeline(this.#temporalPipeline),n.setBindGroup(0,this.#temporalGroup),n.setBindGroup(1,this.#postDynamicGroup),n.dispatchWorkgroups(i[0],i[1]),n.end(),(r=t.beginComputePass()).setPipeline(this.#reprojectPipeline),r.setBindGroup(0,this.#reprojectGroup),r.setBindGroup(1,this.#postDynamicGroup),r.dispatchWorkgroups(i[0],i[1]),r.end()),this.#AAObject&&this.#AAObject.renderFrame(t),t.beginComputePass()),n=(a.setPipeline(this.#canvasPipeline),a.setBindGroup(0,this.#canvasGroup),a.setBindGroup(1,this.#postDynamicGroup),a.dispatchWorkgroups(i[0],i[1]),a.end(),t.finish());this.device.queue.submit([n])}},rasterizer_vertex_default="#version 300 es\n#define TRIANGLES_PER_ROW_POWER 8\n#define TRIANGLES_PER_ROW 256\n#define INV_65536 0.00001525879\n\nprecision highp int;\nprecision highp float;\nprecision highp sampler2D;\n\nin int triangleId;\nin int vertexId;\n\nlayout (std140) uniform transformMatrix\n{\n    mat3 rotation[MAX_TRANSFORMS];\n    vec3 shift[MAX_TRANSFORMS];\n};\n\nuniform vec3 cameraPosition;\nuniform mat3 viewMatrix;\n\n// Texture with vertex information about all triangles in scene\nuniform sampler2D geometryTex;\n\nout vec3 position;\nout vec2 uv;\nout vec3 clipSpace;\n\nflat out vec3 camera;\nflat out int fragmentTriangleId;\nflat out int transformationId;\n\nconst vec2 baseUVs[3] = vec2[3](vec2(1, 0), vec2(0, 1), vec2(0, 0));\n\nvoid main() {\n    // Calculate vertex position in texture\n    int triangleColumn = triangleId >> TRIANGLES_PER_ROW_POWER;\n    ivec2 index = ivec2((triangleId - triangleColumn * TRIANGLES_PER_ROW) * 3, triangleColumn);\n    vec4 t0 = texelFetch(geometryTex, index, 0);\n    vec4 t1 = texelFetch(geometryTex, index + ivec2(1, 0), 0);\n    vec4 t2 = texelFetch(geometryTex, index + ivec2(2, 0), 0);\n    // Combine vertex position\n    vec3 position3d;\n    switch (vertexId) {\n        case 0:\n            position3d = t0.xyz;\n            break;\n        case 1:\n            position3d = vec3(t0.w, t1.xy);\n            break;\n        case 2:\n            position3d = vec3(t1.zw, t2.x);\n            break;\n    }\n    transformationId = int(t2.y);\n    // Apply local geometry transform\n    int tI = transformationId << 1;\n    vec3 localGeometry = rotation[tI] * position3d + shift[tI];\n    vec3 move3d = localGeometry - cameraPosition;\n    clipSpace = viewMatrix * move3d;\n\n    // Set triangle position in clip space\n    gl_Position = vec4(clipSpace.xy, -1.0f / (1.0f + exp(- length(move3d * INV_65536))), clipSpace.z);\n    position = position3d;\n\n    uv = baseUVs[vertexId];\n    camera = cameraPosition;\n    fragmentTriangleId = triangleId;\n}\n",rasterizer_fragment_default="#version 300 es\n#define TRIANGLES_PER_ROW_POWER 8\n#define TRIANGLES_PER_ROW 256\n#define PI 3.141592653589793\n#define PHI 1.61803398874989484820459\n#define SQRT3 1.7320508075688772\n#define POW32 4294967296.0\n#define BIAS 0.0000152587890625\n#define THIRD 0.3333333333333333\n#define INV_PI 0.3183098861837907\n#define INV_256 0.00390625\n#define INV_255 0.00392156862745098\n#define INV_65536 0.0000152587890625\n\nprecision highp float;\nprecision highp sampler2D;\n\nstruct Ray {\n    vec3 origin;\n    vec3 unitDirection;\n};\n\nstruct Material {\n    vec3 albedo;\n    vec3 rme;\n    vec3 tpo;\n};\n\nin vec3 position;\nin vec2 uv;\nin vec3 clipSpace;\n\nflat in vec3 camera;\nflat in int fragmentTriangleId;\nflat in int transformationId;\n\nlayout (std140) uniform transformMatrix\n{\n    mat3 rotation[MAX_TRANSFORMS];\n    vec3 shift[MAX_TRANSFORMS];\n};\n// Get global illumination color, intensity\nuniform vec3 ambient;\n// Textures in parallel for texture atlas\nuniform vec2 textureDims;\nuniform int hdr;\n// Texture with information about all triangles in scene\nuniform sampler2D geometryTex;\nuniform sampler2D sceneTex;\n// Random texture to multiply with normal map to simulate rough surfaces\nuniform sampler2D translucencyTex;\nuniform sampler2D pbrTex;\nuniform sampler2D tex;\n// Texture with all primary light sources of scene\nuniform sampler2D lightTex;\n\nlayout(location = 0) out vec4 renderColor;\n\n\n// Lookup values for texture atlases\nvec3 lookup(sampler2D atlas, vec3 coords) {\n    vec2 atlasSize = vec2(textureSize(atlas, 0));\n    vec2 offset = vec2(\n        mod((textureDims.x * coords.z), atlasSize.x),\n        floor((textureDims.x * coords.z) / atlasSize.x) * textureDims.y\n    );\n    vec2 atlasCoords = (offset + coords.xy * textureDims) / atlasSize;\n    // Return texel on requested location\n    return texture(atlas, atlasCoords).xyz;\n}\n\n// Simplified Moeller-Trumbore algorithm for detecting only forward facing triangles\nbool moellerTrumboreCull(mat3 t, Ray ray, float l) {\n    vec3 edge1 = t[1] - t[0];\n    vec3 edge2 = t[2] - t[0];\n    vec3 pvec = cross(ray.unitDirection, edge2);\n    float det = dot(edge1, pvec);\n    float invDet = 1.0f / det;\n    if(det < BIAS) return false;\n    vec3 tvec = ray.origin - t[0];\n    float u = dot(tvec, pvec) * invDet;\n    if(u < BIAS || u > 1.0f) return false;\n    vec3 qvec = cross(tvec, edge1);\n    float v = dot(ray.unitDirection, qvec) * invDet;\n    if(v < BIAS || u + v > 1.0f) return false;\n    float s = dot(edge2, qvec) * invDet;\n    return (s <= l && s > BIAS);\n}\n\n// Don't return intersection point, because we're looking for a specific triangle not bounding box\nbool rayCuboid(float l, Ray ray, vec3 minCorner, vec3 maxCorner) {\n    vec3 v0 = (minCorner - ray.origin) / ray.unitDirection;\n    vec3 v1 = (maxCorner - ray.origin) / ray.unitDirection;\n    float tmin = max(max(min(v0.x, v1.x), min(v0.y, v1.y)), min(v0.z, v1.z));\n    float tmax = min(min(max(v0.x, v1.x), max(v0.y, v1.y)), max(v0.z, v1.z));\n    return tmax >= max(tmin, BIAS) && tmin < l;\n}\n\n// Simplified rayTracer to only test if ray intersects anything\nbool shadowTest(Ray ray, float l) {\n    // Cache transformed ray attributes\n    Ray tR = Ray(ray.origin, ray.unitDirection);\n    int cachedTI = 0;\n    // Precompute max length\n    float minLen = l;\n    // Get texture size as max iteration value\n    int size = textureSize(geometryTex, 0).y * TRIANGLES_PER_ROW;\n    // Iterate through lines of texture\n    for(int i = 0; i < size; i++) {\n        // Get position of current triangle/vertex in geometryTex\n        int triangleColumn = i >> TRIANGLES_PER_ROW_POWER;\n        ivec2 index = ivec2((i - triangleColumn * TRIANGLES_PER_ROW) * 3, triangleColumn);\n        // Fetch triangle coordinates from scene graph\n        vec4 t0 = texelFetch(geometryTex, index, 0);\n        vec4 t1 = texelFetch(geometryTex, index + ivec2(1, 0), 0);\n        vec4 t2 = texelFetch(geometryTex, index + ivec2(2, 0), 0);\n\n        int tI = int(t2.y) << 1;\n        // Test if cached transformed variables are still valid\n        if (tI != cachedTI) {\n            int iI = tI + 1;\n            mat3 rotationII = rotation[iI];\n            cachedTI = tI;\n            tR = Ray(\n                rotationII * (ray.origin + shift[iI]),\n                normalize(rotationII * ray.unitDirection)\n            );\n        }\n        // Three cases:\n        // t2.z = 0        => end of list: stop loop\n        // t2.z = 1        => is bounding volume: do AABB intersection test\n        // t2.z = 2        => is triangle: do triangle intersection test\n        if (t2.z == 0.0) return false;\n\n        if (t2.z == 1.0) {\n            if (!rayCuboid(minLen, tR, t0.xyz, vec3(t0.w, t1.xy))) i += int(t1.z);\n        } else {\n            mat3 triangle = mat3 (t0, t1, t2.x);\n            // Test for triangle intersection in positive light ray direction\n            if (moellerTrumboreCull(triangle, tR, minLen)) return true;\n        }\n    }\n    // Tested all triangles, but there is no intersection\n    return false;\n}\n\nfloat trowbridgeReitz(float alpha, float NdotH) {\n    float numerator = alpha * alpha;\n    float denom = NdotH * NdotH * (numerator - 1.0f) + 1.0f;\n    return numerator / max(PI * denom * denom, BIAS);\n}\n\nfloat schlickBeckmann(float alpha, float NdotX) {\n    float k = alpha * 0.5f;\n    float denominator = NdotX * (1.0f - k) + k;\n    denominator = max(denominator, BIAS);\n    return NdotX / denominator;\n}\n\nfloat smith(float alpha, float NdotV, float NdotL) {\n    return schlickBeckmann(alpha, NdotV) * schlickBeckmann(alpha, NdotL);\n}\n\nvec3 fresnel(vec3 F0, float theta) {\n    // Use Schlick approximation\n    return F0 + (1.0f - F0) * pow(1.0f - theta, 5.0f);\n}\n\nvec3 forwardTrace(Material material, vec3 lightDir, float strength, vec3 N, vec3 V) {\n    float lenP1 = 1.0f + length(lightDir);\n    // Apply inverse square law\n    float brightness = strength / (lenP1 * lenP1);\n\n    vec3 L = normalize(lightDir);\n    vec3 H = normalize(V + L);\n\n    float VdotH = max(dot(V, H), 0.0f);\n    float NdotL = max(dot(N, L), 0.0f);\n    float NdotH = max(dot(N, H), 0.0f);\n    float NdotV = max(dot(N, V), 0.0f);\n\n    float alpha = material.rme.x * material.rme.x;\n    float BRDF = mix(1.0f, NdotV, material.rme.y);\n    vec3 F0 = material.albedo * BRDF;\n\n    vec3 Ks = fresnel(F0, VdotH);\n    vec3 Kd = (1.0f - Ks) * (1.0f - material.rme.y);\n    vec3 lambert = material.albedo * INV_PI;\n\n    vec3 cookTorranceNumerator = Ks * trowbridgeReitz(alpha, NdotH) * smith(alpha, NdotV, NdotL);\n    float cookTorranceDenominator = 4.0f * NdotV * NdotL;\n    cookTorranceDenominator = max(cookTorranceDenominator, BIAS);\n\n    vec3 cookTorrance = cookTorranceNumerator / cookTorranceDenominator;\n    vec3 radiance = Kd * lambert + cookTorrance;\n\n    // Outgoing light to camera\n    return radiance * NdotL * brightness;\n}\n\nvoid main() {\n\n    // Calculate vertex position in texture\n    int triangleColumn = fragmentTriangleId >> 8;\n    ivec2 index = ivec2((fragmentTriangleId - triangleColumn * TRIANGLES_PER_ROW) * 7, triangleColumn);\n\n    // Fetch texture data\n    vec4 t0 = texelFetch(sceneTex, index, 0);\n    vec4 t1 = texelFetch(sceneTex, index + ivec2(1, 0), 0);\n    vec4 t2 = texelFetch(sceneTex, index + ivec2(2, 0), 0);\n    vec4 t3 = texelFetch(sceneTex, index + ivec2(3, 0), 0);\n    vec4 t4 = texelFetch(sceneTex, index + ivec2(4, 0), 0);\n    vec4 t5 = texelFetch(sceneTex, index + ivec2(5, 0), 0);\n    vec4 t6 = texelFetch(sceneTex, index + ivec2(6, 0), 0);\n\n    // Calculate barycentric coordinates to map textures\n    // Assemble 3 vertex normals\n    mat3 normals = mat3 (\n        t0.xyz, \n        vec3(t0.w, t1.xy),\n        vec3(t1.zw, t2.x)\n    );\n    // Transform normal according to object transform\n    int tI = transformationId << 1;\n    vec3 absolutePosition = rotation[tI] * position + shift[tI];\n    // Transform normal with local transform\n    vec3 smoothNormal = normalize(rotation[tI] * (normals * vec3(uv, 1.0f - uv.x - uv.y)));\n    // Create 3 2-component vectors for the UV's of the respective vertex\n    mat3x2 vertexUVs = mat3x2(t2.yzw, t3.xyz);\n    // Interpolate final barycentric texture coordinates\n    vec2 barycentric = vertexUVs * vec3(uv, 1.0f - uv.x - uv.y);\n    // Read texture id's used as material\n    vec3 texNums = vec3(t3.w, t4.xy);\n    // Gather material attributes (albedo, roughness, metallicity, emissiveness, translucency, partical density and optical density aka. IOR) out of world texture\n    Material material = Material(\n        mix(\n            vec3(t4.zw, t5.x), \n            lookup(tex, vec3(barycentric, texNums.x)).xyz, \n            max(sign(texNums.x + 0.5f), 0.0f)\n        ),\n        mix(\n            t5.yzw, \n            lookup(pbrTex, vec3(barycentric, texNums.y)).xyz, \n            max(sign(texNums.y + 0.5f), 0.0f)\n        ),\n        mix(\n            t6.xyz, \n            lookup(translucencyTex, vec3(barycentric, texNums.z)).xyz, \n            max(sign(texNums.z + 0.5f), 0.0f)\n        )\n    );\n\n    vec3 finalColor = vec3(material.rme.z + ambient) * material.albedo;\n    // Calculate primary light sources for this pass if ray hits non translucent object\n    for(int j = 0; j < textureSize(lightTex, 0).y; j++) {\n        // Read light position\n        vec3 light = texelFetch(lightTex, ivec2(0, j), 0).xyz;\n        // Read light strength from texture\n        float strength = texelFetch(lightTex, ivec2(1, j), 0).x;\n        // Skip if strength is negative or zero\n        if(strength <= 0.0f) continue;\n\n        // Form light vector\n        vec3 dir = light - absolutePosition;\n        Ray lightRay = Ray(absolutePosition, normalize(dir));\n        vec3 localColor = forwardTrace(material, light - position, strength, smoothNormal, normalize(camera - position));\n        // Compute quick exit criterion to potentially skip expensive shadow test\n        bool showColor = length(localColor) == 0.0f;\n\n        // lightRay.origin += sin(acos(dot(smoothNormal, geometryNormal))) * smoothNormal;\n        // Update pixel color if coordinate is not in shadow\n        if(showColor || !shadowTest(lightRay, length(dir))) finalColor += localColor;\n    }\n\n    // finalColor *= material.albedo;\n\n    float translucencyFactor = min(1.0 + max(finalColor.x, max(finalColor.y, finalColor.z)) - material.tpo.x, 1.0);\n    finalColor = mix(material.albedo * material.albedo, finalColor, translucencyFactor);\n\n    if(hdr == 1) {\n        // Apply Reinhard tone mapping\n        finalColor = finalColor / (finalColor + vec3(1.0f));\n        // Gamma correction\n        // float gamma = 0.8f;\n        // finalColor = pow(4.0f * finalColor, vec3(1.0f / gamma)) / 4.0f * 1.3f;\n    }\n\n    renderColor = vec4(finalColor, 1.0f - (0.5 * material.tpo.x));\n}\n",RasterizerWGL2=class{type="rasterizer";config;fps=0;fpsLimit=1/0;#antialiasing;#AAObject;#gl;#canvas;#halt=!1;#geometryTexture;#sceneTexture;#triangleIdBufferArray;#bufferLength;#textureAtlas;#pbrAtlas;#translucencyAtlas;#textureList=[];#pbrList=[];#translucencyList=[];#lightTexture;constructor(e,t,i,n){this.#canvas=e,this.camera=i,this.config=n,this.scene=t,this.#gl=e.getContext("webgl2")}halt=()=>{try{this.#gl.loseContext()}catch(e){console.warn("Unable to lose previous context, reload page in case of performance issue")}this.#halt=!0};get canvas(){return this.#canvas}async#updateAtlas(e){if(0===e.length)this.#gl.texImage2D(this.#gl.TEXTURE_2D,0,this.#gl.RGBA,1,1,0,this.#gl.RGBA,this.#gl.UNSIGNED_BYTE,new Uint8Array(4));else{let[i,n]=this.scene.standardTextureSizes,r=Math.floor(2048/i);var t=document.createElement("canvas");let a=t.getContext("2d");t.width=Math.min(i*e.length,2048),t.height=n*(Math.floor(i*e.length/2048)+1),console.log(t.width,t.height),a.imageSmoothingEnabled=!1,e.forEach(async(e,t)=>a.drawImage(e,i*(t%r),n*Math.floor(t/r),i,n)),this.#gl.texImage2D(this.#gl.TEXTURE_2D,0,this.#gl.RGBA,this.#gl.RGBA,this.#gl.UNSIGNED_BYTE,t)}}async#updateTextureAtlas(){this.scene.textures.length===this.#textureList.length&&this.scene.textures.every((e,t)=>e===this.#textureList[t])||(this.#textureList=this.scene.textures,this.#gl.bindTexture(this.#gl.TEXTURE_2D,this.#textureAtlas),this.#gl.pixelStorei(this.#gl.UNPACK_ALIGNMENT,1),GLLib.setTexParams(this.#gl),this.#updateAtlas(this.scene.textures))}async#updatePbrAtlas(){this.scene.pbrTextures.length===this.#pbrList.length&&this.scene.pbrTextures.every((e,t)=>e===this.#pbrList[t])||(this.#pbrList=this.scene.pbrTextures,this.#gl.bindTexture(this.#gl.TEXTURE_2D,this.#pbrAtlas),this.#gl.pixelStorei(this.#gl.UNPACK_ALIGNMENT,1),GLLib.setTexParams(this.#gl),this.#updateAtlas(this.scene.pbrTextures))}async#updateTranslucencyAtlas(){this.scene.translucencyTextures.length===this.#translucencyList.length&&this.scene.translucencyTextures.every((e,t)=>e===this.#translucencyList[t])||(this.#translucencyList=this.scene.translucencyTextures,this.#gl.bindTexture(this.#gl.TEXTURE_2D,this.#translucencyAtlas),this.#gl.pixelStorei(this.#gl.UNPACK_ALIGNMENT,1),GLLib.setTexParams(this.#gl),this.#updateAtlas(this.scene.translucencyTextures))}updatePrimaryLightSources(){var n;this.#gl.bindTexture(this.#gl.TEXTURE_2D,this.#lightTexture),this.#gl.pixelStorei(this.#gl.UNPACK_ALIGNMENT,1),GLLib.setTexParams(this.#gl),0===this.scene.primaryLightSources.length?this.#gl.texImage2D(this.#gl.TEXTURE_2D,0,this.#gl.RGB32F,1,1,0,this.#gl.RGB,this.#gl.FLOAT,new Float32Array(3)):(n=[],this.scene.primaryLightSources.forEach(e=>{var t=Object.is(e.intensity)?this.scene.defaultLightIntensity:e.intensity,i=Object.is(e.variation)?this.scene.defaultLightVariation:e.variation;n.push(e[0],e[1],e[2],t,i,0)}),this.#gl.texImage2D(this.#gl.TEXTURE_2D,0,this.#gl.RGB32F,2,this.scene.primaryLightSources.length,0,this.#gl.RGB,this.#gl.FLOAT,Float32Array.from(n)))}async updateScene(){var e=await this.scene.generateArraysFromGraph();this.#bufferLength=e.bufferLength,this.#triangleIdBufferArray=e.idBuffer,this.#gl.bindTexture(this.#gl.TEXTURE_2D,this.#geometryTexture),this.#gl.pixelStorei(this.#gl.UNPACK_ALIGNMENT,4),GLLib.setTexParams(this.#gl),this.#gl.texImage2D(this.#gl.TEXTURE_2D,0,this.#gl.RGBA32F,768,e.geometryBufferHeight,0,this.#gl.RGBA,this.#gl.FLOAT,e.geometryBuffer),this.#gl.bindTexture(this.#gl.TEXTURE_2D,this.#sceneTexture),GLLib.setTexParams(this.#gl),this.#gl.pixelStorei(this.#gl.UNPACK_ALIGNMENT,4),this.#gl.texImage2D(this.#gl.TEXTURE_2D,0,this.#gl.RGBA32F,1792,e.sceneBufferHeight,0,this.#gl.RGBA,this.#gl.FLOAT,e.sceneBuffer)}render(){let n=this;n.#halt=!1;let r,a,o,s,l,c,u,h,f,m,d,g,p,v,_,x,y,b,t=this.#gl.createTexture(),T=this.#gl.createVertexArray(),A=()=>{this.#gl.bindTexture(this.#gl.TEXTURE_2D,t),this.#gl.texImage2D(this.#gl.TEXTURE_2D,0,this.#gl.DEPTH_COMPONENT24,n.canvas.width,n.canvas.height,0,this.#gl.DEPTH_COMPONENT,this.#gl.UNSIGNED_INT,null),GLLib.setTexParams(this.#gl)},R=e=>{if(!this.#halt){var t=performance.now();if(this.#updateTextureAtlas(),this.#updatePbrAtlas(),this.#updateTranslucencyAtlas(),this.updatePrimaryLightSources(),e.renderQuality!==this.config.renderQuality&&(w(),e=G()),e.antialiasing!==this.config.antialiasing){e.antialiasing=this.config.antialiasing;var i=this.config.antialiasing.toLowerCase();switch(i){case"fxaa":this.#antialiasing=i,this.#AAObject=new FXAA(this.#gl,this.#canvas);break;case"taa":this.#antialiasing=i,this.#AAObject=new TAA(this.#gl,this.#canvas);break;default:this.#antialiasing=void 0,this.#AAObject=void 0}}S(e),e.intermediateFrames++,e.temporalFrame=(e.temporalFrame+1)%this.config.temporalSamples;var n=t-e.lastTimeStamp;500<n&&(this.fps=(1e3*e.intermediateFrames/n).toFixed(0),e.lastTimeStamp=t,e.intermediateFrames=0),setTimeout(function(){requestAnimationFrame(()=>R(e))},1e3/this.fpsLimit)}},i=()=>{let e={x:0,y:0};void 0!==this.#antialiasing&&"taa"===this.#antialiasing.toLocaleLowerCase()&&(e=this.#AAObject.jitter());var t={x:this.camera.direction.x+e.x,y:this.camera.direction.y+e.y},i=1/this.camera.fov,n=this.#canvas.height*i/this.#canvas.width,n=[Math.cos(t.x)*n,0,Math.sin(t.x)*n,-Math.sin(t.x)*Math.sin(t.y)*i,Math.cos(t.y)*i,Math.cos(t.x)*Math.sin(t.y)*i,-Math.sin(t.x)*Math.cos(t.y),-Math.sin(t.y),Math.cos(t.x)*Math.cos(t.y)],i=(this.#gl.bindVertexArray(T),this.#gl.useProgram(o),[this.#geometryTexture,this.#sceneTexture,this.#pbrAtlas,this.#translucencyAtlas,this.#textureAtlas,this.#lightTexture].forEach((e,t)=>{this.#gl.activeTexture(this.#gl.TEXTURE0+t),this.#gl.bindTexture(this.#gl.TEXTURE_2D,e)}),this.#gl.uniform3f(s,this.camera.position.x,this.camera.position.y,this.camera.position.z),this.#gl.uniformMatrix3fv(l,!0,n),this.#gl.uniform3f(c,this.scene.ambientLight[0],this.scene.ambientLight[1],this.scene.ambientLight[2]),this.#gl.uniform2f(u,this.scene.standardTextureSizes[0],this.scene.standardTextureSizes[1]),this.#gl.uniform1i(h,this.config.hdr),this.#gl.uniform1i(x,0),this.#gl.uniform1i(y,1),this.#gl.uniform1i(f,2),this.#gl.uniform1i(m,3),this.#gl.uniform1i(d,4),this.#gl.uniform1i(g,5),this.#gl.bindBuffer(this.#gl.UNIFORM_BUFFER,p),Transform.buildWGL2Arrays());this.#gl.bufferSubData(this.#gl.UNIFORM_BUFFER,_[0],i.rotationBuffer,0),this.#gl.bufferSubData(this.#gl.UNIFORM_BUFFER,_[1],i.shiftBuffer,0),this.#gl.bindBuffer(this.#gl.UNIFORM_BUFFER,null),this.#gl.bindBuffer(this.#gl.ARRAY_BUFFER,r),this.#gl.bufferData(this.#gl.ARRAY_BUFFER,this.#triangleIdBufferArray,this.#gl.DYNAMIC_DRAW),this.#gl.bindBuffer(this.#gl.ARRAY_BUFFER,a),this.#gl.bufferData(this.#gl.ARRAY_BUFFER,new Int32Array([0,1,2]),this.#gl.STATIC_DRAW),this.#gl.drawArraysInstanced(this.#gl.TRIANGLES,0,3,this.#bufferLength)},S=e=>{void 0!==this.#antialiasing?(this.#gl.bindFramebuffer(this.#gl.FRAMEBUFFER,b),this.#gl.drawBuffers([this.#gl.COLOR_ATTACHMENT0]),this.#gl.framebufferTexture2D(this.#gl.FRAMEBUFFER,this.#gl.COLOR_ATTACHMENT0,this.#gl.TEXTURE_2D,this.#AAObject.textureIn,0),this.#gl.framebufferTexture2D(this.#gl.FRAMEBUFFER,this.#gl.DEPTH_ATTACHMENT,this.#gl.TEXTURE_2D,t,0)):this.#gl.bindFramebuffer(this.#gl.FRAMEBUFFER,null),this.#gl.clear(this.#gl.COLOR_BUFFER_BIT|this.#gl.DEPTH_BUFFER_BIT),i(),void 0!==this.#AAObject&&this.#AAObject.renderFrame()},G=()=>{var e={intermediateFrames:0,lastTimeStamp:performance.now(),filter:this.config.filter,renderQuality:this.config.renderQuality},t=(this.#textureList=[],this.#pbrList=[],this.#translucencyList=[],Math.floor(.25*(Math.min(this.#gl.getParameter(this.#gl.MAX_VERTEX_UNIFORM_VECTORS),this.#gl.getParameter(this.#gl.MAX_FRAGMENT_UNIFORM_VECTORS))-16))),i=(console.log("MAX_TRANSFORMS evaluated to",t),GLLib.addCompileTimeConstant(rasterizer_vertex_default,"MAX_TRANSFORMS",t)),t=GLLib.addCompileTimeConstant(rasterizer_fragment_default,"MAX_TRANSFORMS",t),i=(o=GLLib.compile(this.#gl,i,t),this.#gl.bindVertexArray(T),s=this.#gl.getUniformLocation(o,"cameraPosition"),c=this.#gl.getUniformLocation(o,"ambient"),x=this.#gl.getUniformLocation(o,"geometryTex"),y=this.#gl.getUniformLocation(o,"sceneTex"),u=this.#gl.getUniformLocation(o,"textureDims"),h=this.#gl.getUniformLocation(o,"hdr"),l=this.#gl.getUniformLocation(o,"viewMatrix"),this.#gl.getUniformBlockIndex(o,"transformMatrix")),t=this.#gl.getActiveUniformBlockParameter(o,i,this.#gl.UNIFORM_BLOCK_DATA_SIZE),i=(p=this.#gl.createBuffer(),this.#gl.bindBuffer(this.#gl.UNIFORM_BUFFER,p),this.#gl.bufferData(this.#gl.UNIFORM_BUFFER,t,this.#gl.DYNAMIC_DRAW),this.#gl.bindBuffer(this.#gl.UNIFORM_BUFFER,null),this.#gl.bindBufferBase(this.#gl.UNIFORM_BUFFER,0,p),v=this.#gl.getUniformIndices(o,["rotation","shift"]),_=this.#gl.getActiveUniforms(o,v,this.#gl.UNIFORM_OFFSET),this.#gl.getUniformBlockIndex(o,"transformMatrix"));return this.#gl.uniformBlockBinding(o,i,0),g=this.#gl.getUniformLocation(o,"lightTex"),f=this.#gl.getUniformLocation(o,"pbrTex"),m=this.#gl.getUniformLocation(o,"translucencyTex"),d=this.#gl.getUniformLocation(o,"tex"),this.#gl.enable(this.#gl.BLEND),this.#gl.enable(this.#gl.DEPTH_TEST),this.#gl.blendEquation(this.#gl.FUNC_ADD),this.#gl.blendFuncSeparate(this.#gl.ONE,this.#gl.ONE_MINUS_SRC_ALPHA,this.#gl.ONE,this.#gl.ONE),this.#gl.depthMask(!0),this.#gl.clearColor(0,0,0,0),this.#gl.useProgram(o),n.#pbrAtlas=this.#gl.createTexture(),n.#translucencyAtlas=this.#gl.createTexture(),n.#textureAtlas=this.#gl.createTexture(),n.#lightTexture=this.#gl.createTexture(),this.#geometryTexture=this.#gl.createTexture(),this.#sceneTexture=this.#gl.createTexture(),[r,a]=[this.#gl.createBuffer(),this.#gl.createBuffer()],this.#gl.bindBuffer(this.#gl.ARRAY_BUFFER,r),this.#gl.enableVertexAttribArray(0),this.#gl.vertexAttribIPointer(0,1,this.#gl.INT,!1,0,0),this.#gl.vertexAttribDivisor(0,1),this.#gl.bindBuffer(this.#gl.ARRAY_BUFFER,a),this.#gl.enableVertexAttribArray(1),this.#gl.vertexAttribIPointer(1,1,this.#gl.INT,!1,0,0),b=this.#gl.createFramebuffer(),A(),this.updateScene(),e},w=()=>{this.canvas.width=this.canvas.clientWidth*this.config.renderQuality,this.canvas.height=this.canvas.clientHeight*this.config.renderQuality,this.#gl.viewport(0,0,this.canvas.width,this.canvas.height),A(),void 0!==this.#AAObject&&this.#AAObject.createTexture()};w(),window.addEventListener("resize",w),G(),requestAnimationFrame(R)}},rasterRenderFormats2=["rgba32float","rg32float"],POW32U2=2**32-1,TEMPORAL_MAX2=8388607,RasterizerWGPU=class extends Renderer{type="rasterizer";config;fps=0;fpsLimit=1/0;#canvas;#context;#adapter;device;#preferedCanvasFormat;#depthPipeline;#rasterPipeline;#computePipeline;#shiftPipeline;#temporalPipeline;#reprojectPipeline;#canvasPipeline;#renderPassDescriptor;#staticBuffers;#dynamicBuffers;#uniformBuffer;#transformBuffer;#depthBuffer;#triangleIdBuffer;#rasterRenderTextures=[];#temporalIn;#shiftTarget;#accumulatedTarget;#shiftLock;#canvasIn;#depthGroupLayout;#rasterRenderGroupLayout;#computeRenderGroupLayout;#rasterDynamicGroupLayout;#computeDynamicGroupLayout;#rasterStaticGroupLayout;#computeStaticGroupLayout;#postDynamicGroupLayout;#shiftGroupLayout;#temporalGroupLayout;#reprojectGroupLayout;#canvasGroupLayout;#depthGroup;#rasterRenderGroup;#computeRenderGroup;#rasterDynamicGroup;#computeDynamicGroup;#rasterStaticGroup;#computeStaticGroup;#postDynamicGroup;#shiftGroup;#temporalGroup;#canvasGroup;#reprojectGroup;#engineState={};#resizeEvent;#halt=!0;#antialiasing;#AAObject;constructor(e,t,i,n){super(t),this.#canvas=e,this.camera=i,this.config=n,navigator.gpu}halt=()=>{this.#halt=!0,window.removeEventListener("resize",this.#resizeEvent)};resize(){let t=Math.round(this.#canvas.clientWidth*this.config.renderQuality),i=Math.round(this.#canvas.clientHeight*this.config.renderQuality);this.#canvas.width=t,this.#canvas.height=i;var e=[this.#canvasIn,...this.#rasterRenderTextures];this.config.temporal&&e.push(this.#shiftTarget,this.#temporalIn),e.forEach(e=>{try{e.destroy()}catch{}}),this.#depthBuffer=this.device.createBuffer({size:i*t*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.#triangleIdBuffer=this.device.createBuffer({size:i*t*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.#rasterRenderTextures=rasterRenderFormats2.map(e=>this.device.createTexture({size:[t,i],format:e,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING})),this.#canvasIn=this.device.createTexture({size:[t,i],format:"rgba32float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING}),this.config.temporal&&(this.#temporalIn=this.device.createTexture({size:[t,i,this.config.temporal?2:1],format:"rgba32float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING}),this.#shiftTarget=this.device.createTexture({size:[t,i,5],format:"rgba32float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING}),this.#accumulatedTarget=this.device.createTexture({size:[t,i,5],format:"rgba32float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING}),this.#shiftLock=this.device.createBuffer({size:t*i*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.device.queue.writeBuffer(this.#shiftLock,0,new Uint32Array(new Array(t*i).fill(POW32U2)))),this.#AAObject&&this.#AAObject.createTexture()}get canvas(){return this.#canvas}updateScene(i=this.device){var e;i&&(console.log(this.scene.queue),e=this.scene.generateArraysFromGraph(),this.#engineState.bufferLength=e.bufferLength,this.#staticBuffers=[e.idBuffer,e.geometryBuffer,e.sceneBuffer].map(e=>{var t=i.createBuffer({size:e.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});return i.queue.writeBuffer(t,0,e),t}),e=this.#staticBuffers.map((e,t)=>({binding:t,resource:{buffer:e}})),this.#rasterStaticGroup=i.createBindGroup({label:"static binding group for raster pass",layout:this.#rasterStaticGroupLayout,entries:e.slice(0,2)}),this.#computeStaticGroup=i.createBindGroup({label:"static binding group for compute pass",layout:this.#computeStaticGroupLayout,entries:e}))}async render(){this.#halt?(this.#context=this.#canvas.getContext("webgpu"),this.#adapter=await navigator.gpu.requestAdapter(),this.device=await this.#adapter.requestDevice(),this.#preferedCanvasFormat="rgba8unorm",this.#context.configure({device:this.device,format:this.#preferedCanvasFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING}),this.#engineState.intermediateFrames=0,this.#engineState.lastTimeStamp=performance.now(),this.#engineState.temporalFrame=0,await this.updateTextureAtlas(!0),await this.updatePbrAtlas(!0),await this.updateTranslucencyAtlas(!0),this.#prepareEngine(this.device)):console.warn("Renderer already up and running!")}#prepareEngine(e){this.halt(),this.#halt=!1,Object.assign(this.#engineState,{filter:this.config.filter,temporal:this.config.temporal,temporalSamples:this.config.temporalSamples,renderQuality:this.config.renderQuality,bufferLength:0}),this.#depthGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"storage"}}]}),this.#rasterRenderGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.FRAGMENT,storageTexture:{access:"write-only",format:"rgba32float",viewDimension:"2d"}},{binding:3,visibility:GPUShaderStage.FRAGMENT,storageTexture:{access:"write-only",format:"rg32float",viewDimension:"2d"}}]}),this.#computeRenderGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:"rgba32float",viewDimension:"2d-array"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,texture:{type:"float",sampleType:"unfilterable-float"}},{binding:3,visibility:GPUShaderStage.COMPUTE,texture:{type:"float",sampleType:"unfilterable-float"}}]}),this.#rasterStaticGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}}]}),this.#computeStaticGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}]}),this.#rasterDynamicGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}}]}),this.#computeDynamicGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}]}),this.textureGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{type:"uint"}},{binding:1,visibility:GPUShaderStage.COMPUTE,texture:{type:"uint"}},{binding:2,visibility:GPUShaderStage.COMPUTE,texture:{type:"uint"}}]}),this.config.temporal&&(this.#shiftGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{type:"float",sampleType:"unfilterable-float",viewDimension:"2d-array"}},{binding:1,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:"rgba32float",viewDimension:"2d-array"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),this.#temporalGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{type:"float",sampleType:"unfilterable-float",viewDimension:"2d-array"}},{binding:1,visibility:GPUShaderStage.COMPUTE,texture:{type:"float",sampleType:"unfilterable-float",viewDimension:"2d-array"}},{binding:2,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:"rgba32float",viewDimension:"2d-array"}}]}),this.#reprojectGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{type:"float",sampleType:"unfilterable-float",viewDimension:"2d-array"}},{binding:1,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:"rgba32float",viewDimension:"2d"}}]})),this.#postDynamicGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]}),this.#canvasGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{type:"float",sampleType:"unfilterable-float"}},{binding:1,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:"rgba8unorm",viewDimension:"2d"}}]});var t=e.createShaderModule({code:pathtracer_depth_default}),t=(this.#depthPipeline=e.createRenderPipeline({label:"depth pipeline",layout:e.createPipelineLayout({bindGroupLayouts:[this.#depthGroupLayout,this.#rasterStaticGroupLayout,this.#rasterDynamicGroupLayout]}),vertex:{module:t,entryPoint:"vertex"},fragment:{module:t,entryPoint:"fragment",targets:[{format:"rgba8unorm"}]},primitive:{topology:"triangle-list",cullMode:"back"}}),pathtracer_raster_default),t=e.createShaderModule({code:t}),t=(this.#rasterPipeline=e.createRenderPipeline({label:"raster pipeline",layout:e.createPipelineLayout({bindGroupLayouts:[this.#rasterRenderGroupLayout,this.#rasterStaticGroupLayout,this.#rasterDynamicGroupLayout]}),vertex:{module:t,entryPoint:"vertex"},fragment:{module:t,entryPoint:"fragment",targets:[{format:"rgba8unorm"}]},primitive:{topology:"triangle-list",cullMode:"back"}}),pathtracer_compute_default),t=e.createShaderModule({code:t}),t=(this.#computePipeline=e.createComputePipeline({label:"compute pipeline",layout:e.createPipelineLayout({bindGroupLayouts:[this.#computeRenderGroupLayout,this.textureGroupLayout,this.#computeStaticGroupLayout,this.#computeDynamicGroupLayout]}),compute:{module:t,entryPoint:"compute"}}),this.config.temporal&&(t=e.createShaderModule({code:pathtracer_shift_default}),this.#shiftPipeline=e.createComputePipeline({label:"shift pipeline",layout:e.createPipelineLayout({bindGroupLayouts:[this.#shiftGroupLayout,this.#postDynamicGroupLayout]}),compute:{module:t,entryPoint:"compute"}}),t=e.createShaderModule({code:pathtracer_selective_average_default}),this.#temporalPipeline=e.createComputePipeline({label:"selective average pipeline",layout:e.createPipelineLayout({bindGroupLayouts:[this.#temporalGroupLayout,this.#postDynamicGroupLayout]}),compute:{module:t,entryPoint:"compute"}}),t=e.createShaderModule({code:pathtracer_reproject_default}),this.#reprojectPipeline=e.createComputePipeline({label:"reproject pipeline",layout:e.createPipelineLayout({bindGroupLayouts:[this.#reprojectGroupLayout,this.#postDynamicGroupLayout]}),compute:{module:t,entryPoint:"compute"}})),canvas_default),t=e.createShaderModule({code:t});this.#canvasPipeline=e.createComputePipeline({label:"canvas pipeline",layout:e.createPipelineLayout({bindGroupLayouts:[this.#canvasGroupLayout,this.#postDynamicGroupLayout]}),compute:{module:t,entryPoint:"compute"}}),this.#renderPassDescriptor={colorAttachments:[{clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"}]},this.#uniformBuffer=e.createBuffer({size:176,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.updateScene(e),this.resize(),this.#resizeEvent=window.addEventListener("resize",()=>this.resize()),requestAnimationFrame(()=>this.frameCycle(e))}frameCycle(e){if(!this.#halt){var t=performance.now();if(this.#engineState.temporal!==this.config.temporal||this.#engineState.temporalSamples!==this.config.temporalSamples||this.#engineState.renderQuality!==this.config.renderQuality)requestAnimationFrame(()=>this.#prepareEngine(e));else{if(this.updateTextureAtlas(),this.updatePbrAtlas(),this.updateTranslucencyAtlas(),this.updateTextureGroup(),this.updatePrimaryLightSources(),this.#engineState.antialiasing!==this.config.antialiasing){this.#engineState.antialiasing=this.config.antialiasing;var i=this.config.antialiasing.toLowerCase();switch(i){case"fxaa":this.#antialiasing=i,this.#AAObject=new FXAA2(this.device,this.#canvas);break;case"taa":this.#antialiasing=i,this.#AAObject=new TAA2(this.device,this.#canvas);break;default:this.#antialiasing=void 0,this.#AAObject=void 0}}this.renderFrame(),this.#engineState.intermediateFrames++,this.#engineState.temporalFrame=(this.#engineState.temporalFrame+1)%TEMPORAL_MAX2;var n=t-this.#engineState.lastTimeStamp;500<n&&(this.fps=(1e3*this.#engineState.intermediateFrames/n).toFixed(0),this.#engineState.lastTimeStamp=t,this.#engineState.intermediateFrames=0),setTimeout(()=>{requestAnimationFrame(()=>this.frameCycle(e))},1e3/this.fpsLimit)}}}async renderFrame(){let e={x:0,y:0};this.#AAObject&&"taa"===this.#antialiasing&&(e=this.#AAObject.jitter());var t={x:this.camera.direction.x,y:this.camera.direction.y},i={x:this.camera.direction.x+e.x,y:this.camera.direction.y+e.y},n=this.#context.getCurrentTexture(),r={binding:0,resource:{buffer:this.#depthBuffer}},a=this.config.temporal||this.#AAObject?!this.config.temporal&&this.#AAObject?this.#AAObject.textureInView2dArray:this.#temporalIn.createView({dimension:"2d-array",arrayLayerCount:2}):this.#canvasIn.createView({dimension:"2d-array",arrayLayerCount:1}),a=(this.#depthGroup=this.device.createBindGroup({label:"depth buffer for depth testing raster pass",layout:this.#depthGroupLayout,entries:[r]}),this.#rasterRenderGroup=this.device.createBindGroup({label:"render output group for raster pass",layout:this.#rasterRenderGroupLayout,entries:[r,{binding:1,resource:{buffer:this.#triangleIdBuffer}},...this.#rasterRenderTextures.map((e,t)=>({binding:t+2,resource:e.createView()}))]}),this.#computeRenderGroup=this.device.createBindGroup({label:"render input group for compute pass",layout:this.#computeRenderGroupLayout,entries:[{binding:0,resource:a},{binding:1,resource:{buffer:this.#triangleIdBuffer}},...this.#rasterRenderTextures.map((e,t)=>({binding:t+2,resource:e.createView()}))]}),this.config.temporal&&(r=this.#AAObject?this.#AAObject.textureInView:this.#canvasIn.createView({dimension:"2d"}),this.#shiftGroup=this.device.createBindGroup({label:"bind group for motion correction pass",layout:this.#shiftGroupLayout,entries:[{binding:0,resource:this.#accumulatedTarget.createView({dimension:"2d-array",arrayLayerCount:5})},{binding:1,resource:this.#shiftTarget.createView({dimension:"2d-array",arrayLayerCount:5})},{binding:2,resource:{buffer:this.#shiftLock}}]}),this.#temporalGroup=this.device.createBindGroup({label:"bind group accumulation pass",layout:this.#temporalGroupLayout,entries:[{binding:0,resource:this.#temporalIn.createView({dimension:"2d-array",arrayLayerCount:2})},{binding:1,resource:this.#shiftTarget.createView({dimension:"2d-array",arrayLayerCount:5})},{binding:2,resource:this.#accumulatedTarget.createView({dimension:"2d-array",arrayLayerCount:5})}]}),this.#reprojectGroup=this.device.createBindGroup({label:"bind group for reprojection pass",layout:this.#reprojectGroupLayout,entries:[{binding:0,resource:this.#accumulatedTarget.createView({dimension:"2d-array",arrayLayerCount:5})},{binding:1,resource:r}]})),this.#AAObject&&this.#AAObject.createBindGroup(this.#canvasIn),this.#canvasGroup=this.device.createBindGroup({label:"render input group for canvas pass",layout:this.#canvasGroupLayout,entries:[{binding:0,resource:this.#canvasIn.createView({dimension:"2d"})},{binding:1,resource:n.createView()}]}),this.#renderPassDescriptor.colorAttachments[0].view=n.createView(),1/this.camera.fov),r=this.#canvas.height*a/this.#canvas.width;let o=[[Math.cos(t.x)*r,0,Math.sin(t.x)*r],[-Math.sin(t.x)*Math.sin(t.y)*a,Math.cos(t.y)*a,Math.cos(t.x)*Math.sin(t.y)*a],[-Math.sin(t.x)*Math.cos(t.y),-Math.sin(t.y),Math.cos(t.x)*Math.cos(t.y)]];var n=[[Math.cos(i.x)*r,0,Math.sin(i.x)*r],[-Math.sin(i.x)*Math.sin(i.y)*a,Math.cos(i.y)*a,Math.cos(i.x)*Math.sin(i.y)*a],[-Math.sin(i.x)*Math.cos(i.y),-Math.sin(i.y),Math.cos(i.x)*Math.cos(i.y)]],t=(this.config.temporal||(o=n),this.config.temporal?this.#engineState.temporalFrame:0),r=(this.device.queue.writeBuffer(this.#uniformBuffer,0,new Float32Array([o[0][0],o[1][0],o[2][0],0,o[0][1],o[1][1],o[2][1],0,o[0][2],o[1][2],o[2][2],0,n[0][0],n[1][0],n[2][0],0,n[0][1],n[1][1],n[2][1],0,n[0][2],n[1][2],n[2][2],0,this.camera.position.x,this.camera.position.y,this.camera.position.z,0,this.scene.ambientLight[0],this.scene.ambientLight[1],this.scene.ambientLight[2],0,this.scene.standardTextureSizes[0],this.scene.standardTextureSizes[1],this.canvas.width,this.canvas.height,this.config.samplesPerRay,this.config.maxReflections,this.config.minImportancy,this.config.filter,this.config.hdr?1:0,this.config.temporal,t,TEMPORAL_MAX2])),Transform.buildWGPUArray()),a=(this.#transformBuffer=this.device.createBuffer({size:r.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.device.queue.writeBuffer(this.#transformBuffer,0,r),this.#dynamicBuffers=[this.#uniformBuffer,this.#transformBuffer,this.lightBuffer],this.#dynamicBuffers.map((e,t)=>({binding:t,resource:{buffer:e}}))),i=(this.#rasterDynamicGroup=this.device.createBindGroup({label:"dynamic binding group for raster pass",layout:this.#rasterDynamicGroupLayout,entries:a.slice(0,2)}),this.#computeDynamicGroup=this.device.createBindGroup({label:"dynamic binding group for compute pass",layout:this.#computeDynamicGroupLayout,entries:a}),this.#postDynamicGroup=this.device.createBindGroup({label:"dynamic binding group for post processing passes",layout:this.#postDynamicGroupLayout,entries:a.slice(0,1)}),[Math.ceil(this.canvas.width/8),Math.ceil(this.canvas.height/8)]),n=[Math.ceil(this.canvas.width/8),Math.ceil(this.canvas.height/8)],t=this.device.createCommandEncoder(),r=(t.clearBuffer(this.#depthBuffer),t.clearBuffer(this.#triangleIdBuffer),t.beginRenderPass(this.#renderPassDescriptor)),a=(r.setPipeline(this.#depthPipeline),r.setBindGroup(0,this.#depthGroup),r.setBindGroup(1,this.#rasterStaticGroup),r.setBindGroup(2,this.#rasterDynamicGroup),r.draw(3,this.#engineState.bufferLength),r.end(),t.beginRenderPass(this.#renderPassDescriptor)),r=(a.setPipeline(this.#rasterPipeline),a.setBindGroup(0,this.#rasterRenderGroup),a.setBindGroup(1,this.#rasterStaticGroup),a.setBindGroup(2,this.#rasterDynamicGroup),a.draw(3,this.#engineState.bufferLength),a.end(),t.beginComputePass()),a=(r.setPipeline(this.#computePipeline),r.setBindGroup(0,this.#computeRenderGroup),r.setBindGroup(1,this.textureGroup),r.setBindGroup(2,this.#computeStaticGroup),r.setBindGroup(3,this.#computeDynamicGroup),r.dispatchWorkgroups(n[0],n[1]),r.end(),this.config.temporal&&((a=t.beginComputePass()).setPipeline(this.#shiftPipeline),a.setBindGroup(0,this.#shiftGroup),a.setBindGroup(1,this.#postDynamicGroup),a.dispatchWorkgroups(i[0],i[1]),a.end(),(n=t.beginComputePass()).setPipeline(this.#temporalPipeline),n.setBindGroup(0,this.#temporalGroup),n.setBindGroup(1,this.#postDynamicGroup),n.dispatchWorkgroups(i[0],i[1]),n.end(),(r=t.beginComputePass()).setPipeline(this.#reprojectPipeline),r.setBindGroup(0,this.#reprojectGroup),r.setBindGroup(1,this.#postDynamicGroup),r.dispatchWorkgroups(i[0],i[1]),r.end()),this.#AAObject&&this.#AAObject.renderFrame(t),t.beginComputePass()),n=(a.setPipeline(this.#canvasPipeline),a.setBindGroup(0,this.#canvasGroup),a.setBindGroup(1,this.#postDynamicGroup),a.dispatchWorkgroups(i[0],i[1]),a.end(),t.finish());this.device.queue.submit([n])}},WebIo=class u7{static#translationMap={right:1,left:-1,down:-2,up:2,backward:-3,forward:3};#isListening=!1;#savedTime;#keyMap={};#pressedKeys={};#movement=[0,0,0];mouseX=4;mouseY=2;movementSpeed=.01;camera;renderer;constructor(e,t,i){this.registerKey("KeyW","forward"),this.registerKey("KeyA","left"),this.registerKey("KeyS","backward"),this.registerKey("KeyD","right"),this.registerKey("Space","up"),this.registerKey("ShiftLeft","down"),this.camera=i,this.renderer=t,this.setupForCanvas(e),requestAnimationFrame(this.frame)}registerKey=(e,t)=>{this.#keyMap[e]=u7.#translationMap[t],this.#pressedKeys[e]=!1};frame=()=>{this.update(performance.now()),requestAnimationFrame(this.frame)};update=e=>{var t,i,n;this.#isListening&&(t=this.camera.position,i=this.camera.direction,n=(e-this.#savedTime)*this.movementSpeed,t.x+=n*(this.#movement[0]*Math.cos(i.x)-this.#movement[2]*Math.sin(i.x)),t.y+=n*this.#movement[1],t.z+=n*(this.#movement[2]*Math.cos(i.x)+this.#movement[0]*Math.sin(i.x)),this.#savedTime=e)};resetMovement=()=>{for(var e in this.#pressedKeys)this.#pressedKeys[e]=!1};updateMovement=e=>this.#movement[Math.abs(e)-1]+=Math.sign(e);setupForCanvas=i=>{let n=this;i.tabIndex=0,i.onfocus=()=>{i.requestPointerLock()},document.onpointerlockchange=e=>{n.#isListening=!n.#isListening,n.#isListening?n.#savedTime=e.timeStamp:(n.resetMovement(),i.blur())},i.onkeydown=e=>{e.code in n.#pressedKeys&&(n.#pressedKeys[e.code]||(n.update(e.timeStamp),n.#pressedKeys[e.code]=!0,n.updateMovement(n.#keyMap[e.code])))},i.onkeyup=e=>{e.code in n.#pressedKeys&&n.#pressedKeys[e.code]&&(n.update(e.timeStamp),n.#pressedKeys[e.code]=!1,n.updateMovement(-n.#keyMap[e.code]))},i.onmousemove=e=>{var t;n.#isListening&&(t=[(t=[n.mouseX/i.width,n.mouseY/i.height])[0]*e.movementX,t[1]*e.movementY],n.camera.direction.x-=t[0],2*Math.abs(n.camera.direction.y+t[1])<Math.PI)&&(n.camera.direction.y+=t[1])}}},UI=class{selected=null;constructor(e,t){this.scene=e,this.camera=t}#runSelector=()=>{setInterval(()=>{var e=[this.camera.x,this.camera.y,this.camera.z],t=[-Math.sin(this.camera.fx)*Math.cos(this.camera.fy),-Math.sin(this.camera.fy),Math.cos(this.camera.fx)*Math.cos(this.camera.fy)],e=(null!==this.selected&&(this.selected.selected=!1),this.getObjectInCenter(this.scene.queue,e,t));e.distance!==1/0?(e.object.selected=!0,this.selected=e.object):this.selected=null},10)};getObjectInCenter=(i,n,r)=>{var e,t,a;if(!Array.isArray(i)&&!i.indexable)return 2===i.length?(e=i.normal,t=[i.vertices.slice(0,3),i.vertices.slice(3,6),i.vertices.slice(6,9)],a=[i.vertices.slice(9,12),i.vertices.slice(12,15),i.vertices.slice(15,18)],{distance:Math.min(Math.rayTriangle(n,r,t[0],t[1],t[2],e),Math.rayTriangle(n,r,a[0],a[1],a[2],e)),object:i}):1===i.length?(t=i.normal,a=[i.vertices.slice(0,3),i.vertices.slice(3,6),i.vertices.slice(6,9)],{distance:Math.rayTriangle(n,r,a[0],a[1],a[2],t),object:i}):void 0;if(0!==i.length){let t=this.getObjectInCenter(i[0],n,r);for(let e=1;e<i.length;e++){var o=this.getObjectInCenter(i[e],n,r);t.distance>o.distance&&(t=o)}return t}}},FlexLight=class{#idRenderer;#idIo;#api;#canvas;#camera;#config;#scene;#renderer;#ui;#io;constructor(e){this.#api="webgl2",this.#canvas=e,this.#camera=new Camera,this.#config=new Config,this.#scene=new Scene,this.#renderer=new RasterizerWGL2(e,this.#scene,this.#camera,this.#config),this.#io=new WebIo(e,this.#renderer,this.#camera),this.#ui=new UI(this.#scene,this.#camera)}get canvas(){return this.#canvas}get api(){return this.#api}get camera(){return this.#camera}get config(){return this.#config}get scene(){return this.#scene}get renderer(){return this.#renderer}get io(){return this.#io}set canvas(e){e!=this.#canvas&&(this.#canvas=e,this.renderer=this.#idRenderer,this.io=this.#idIo)}set api(e){e!=this.#api&&(this.#api=e,e=document.createElement("canvas"),console.log(this.#canvas.parentElement),this.#canvas.parentElement.replaceChild(e,this.#canvas),this.#canvas=e,this.renderer=this.#idRenderer,this.io=this.#idIo)}set config(e){this.#config=e,this.#renderer.config=e}set camera(e){this.#camera=e,this.#renderer.camera=e,this.#scene.camera=e,this.#ui.camera=e}set scene(e){this.#scene=e,this.#ui.scene=e,this.#renderer.scene=e}set renderer(e){switch(this.#idRenderer=e,console.log(this.#idRenderer+this.#api),this.#renderer.halt(),this.#idRenderer+this.#api){case"pathtracerwebgl2":this.#renderer=new PathTracerWGL2(this.#canvas,this.#scene,this.#camera,this.#config);break;case"pathtracerwebgpu":this.#renderer=new PathTracerWGPU(this.#canvas,this.#scene,this.#camera,this.#config);break;case"rasterizerwebgl2":this.#renderer=new RasterizerWGL2(this.#canvas,this.#scene,this.#camera,this.#config);break;case"rasterizerwebgpu":this.#renderer=new RasterizerWGPU(this.#canvas,this.#scene,this.#camera,this.#config);break;default:console.error("Renderer option",this.#idRenderer,"on api",this.#api,"doesn't exist.")}this.#renderer.render()}set io(e){this.#idIo=e??"web","web"===this.#idIo?this.#io=new WebIo(this.#canvas,this.#renderer,this.camera):console.error("Io option",this.#idIo,"doesn't exist."),this.#io.renderer=this.#renderer}screenshot(){this.#canvas.toBlob(e=>{var e=URL.createObjectURL(e),t=document.createElement("a");t.href=e,t.download="screenshot.png",t.click()})}};export{Bounding,Camera,Config,Cuboid,FlexLight,HouseholderMatrix,IdentityMatrix,Matrix,Object3D,PathTracerWGL2,PathTracerWGPU,Plane,Primitive,RasterizerWGL2,RasterizerWGPU,Scene,Transform,Triangle,UI,Vector,WebIo,ZeroMatrix,ZeroVector};